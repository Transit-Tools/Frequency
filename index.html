<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>üöå GTFS Frequency Screener</title>
<style>
  :root{
    /* Light theme (default) */
    --bg:#f3f4f6; --panel:#ffffff; --muted:#9ca3af; --text:#111827; --line:#e5e7eb;
    --chip:#f3f4f6; --chipText:#111827; --accent:#3b82f6; --btn:#3b82f6; --btnText:#fff;
    --good:#10b981; --ok:#22c55e; --mid:#06b6d4; --warn:#f59e0b; --meh:#ef4444; --dark:#6b7280;
    --zebra: rgba(0,0,0,.03);
    --textSecondary:#6b7280;
  }
  .dark{
    /* Dark theme */
    --bg:#0b1220; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb; --line:#1f2937;
    --chip:#1f2937; --chipText:#cbd5e1; --accent:#60a5fa; --btn:#2563eb; --btnText:#fff;
    --good:#10b981; --ok:#22c55e; --mid:#06b6d4; --warn:#f59e0b; --meh:#ef4444; --dark:#374151;
    --zebra: rgba(255,255,255,.02);
    --textSecondary:#9ca3af;
  }
  *{box-sizing:border-box}
  body{
    font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background: var(--bg);
    color: var(--text);
    margin:0; padding:0; min-height:100vh;
    transition:background .3s ease,color .3s ease;
  }
  .dark body, body.dark{
    background: radial-gradient(1200px 600px at 10% 0%, #0e172a 0%, var(--bg) 50%, #090f1b 100%);
  }
  .wrap{max-width:1300px;margin:0 auto;padding:20px;display:flex;flex-direction:column;min-height:100vh}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0;font-weight:800;letter-spacing:.2px}
  .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; box-shadow: 0 2px 8px rgba(0,0,0,.04); padding:16px; margin-bottom:12px}
  .dark .panel{box-shadow: 0 6px 20px rgba(0,0,0,.15)}
  #tableWrap{display:flex;flex-direction:column;flex:1;min-height:0}
  .resultsScroll{flex:unset;min-height:auto;overflow:visible;max-height:none}
  .grid{display:grid; grid-template-columns:2fr 1fr 1fr 1fr; gap:12px; align-items:end}
  label{font-weight:700; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.04em}
  input[type="file"], input[type="time"]{ width:100%; padding:10px 12px; border-radius:10px; background:transparent; border:1px solid var(--line); color:var(--text)}
  input[type="file"]::-webkit-file-upload-button{display:none}
  input[type="file"]::file-selector-button{display:none}
  .field{display:flex;flex-direction:column}
  .field.action{justify-content:flex-end;align-items:flex-end;position:relative}
  .field.action .btn{position:relative;z-index:2}
  .fileName{font-size:12px;color:var(--muted);margin-top:4px;word-break:break-word}
  .rangeMessage{margin-top:8px;font-size:12px;color:#f97316;font-weight:700}
  .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:12px}
  .btn{background:var(--btn); color:var(--btnText); border:1px solid transparent; border-radius:10px; padding:10px 14px; font-weight:800; cursor:pointer; transition:all .2s}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btnTheme{background:var(--chip);border:1px solid var(--line);padding:8px 12px}
  .chip{background:var(--chip); color:var(--chipText); padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid var(--line)}
  .seg{display:flex; gap:6px; background:transparent; border:1px solid var(--line); padding:4px; border-radius:12px}
  .seg button{background:transparent; color:var(--muted); border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700}
  .seg button.active{background:var(--btn); color:#fff}
  .switch{display:flex; gap:8px; align-items:center; color:var(--muted); font-weight:700}
  .switch input{accent-color:var(--accent)}
  .search{flex:1; display:flex; align-items:center; gap:8px; background:transparent; border:1px solid var(--line); padding:8px 10px; border-radius:10px}
  .search input{flex:1; background:transparent; border:0; color:var(--text); outline:none}

  /* Banner */
  #frequentBanner{display:none}
  #frequentBanner h3{margin:0 0 8px;font-size:14px}
  #bannerPills{display:flex;flex-wrap:wrap;gap:8px}
  #bannerPills button{background:#10b981;border:0;color:#fff;font-weight:800;border-radius:6px;padding:6px 12px;cursor:pointer;font-size:14px}
  #bannerPills button:hover{background:#059669}
  #bannerEmpty{color:var(--muted);font-size:13px}

  /* Kanban */
  .kanban{display:grid; grid-template-columns:repeat(6,1fr); gap:12px}
  .col{background:transparent; border:1px solid var(--line); border-radius:14px; padding:12px; min-height:120px}
  .col h3{margin:0 0 8px; font-size:13px; color:var(--chipText); letter-spacing:.03em; text-transform:uppercase}
  .col .hint{color:var(--muted); font-size:12px; margin-bottom:8px}
  .cards{display:flex; flex-direction:column; gap:8px; max-height:280px; overflow:auto}
  .card{background:transparent; border:1px solid var(--line); border-radius:10px; padding:8px 10px; cursor:pointer}
  .card:hover{border-color:#334155}
  .routeLine{display:flex; align-items:center; gap:6px; font-weight:800}
  .routeIcon{width:18px;height:18px;flex-shrink:0;opacity:0.6}
  .day{font-size:11px; color:#94a3b8}
  .dir{font-size:11px; background:transparent; border:1px solid var(--line); color:var(--chipText); padding:2px 6px; border-radius:999px}
  .stat{font-size:11px; color:#a5b4fc}

  /* Table */
  table{width:100%; border-collapse:separate; border-spacing:0; font-size:14px}
  thead th{position:sticky; top:0; backdrop-filter: blur(6px); z-index:3; background:#fffffff0;}
  .dark thead th{background:rgba(17,24,39,.9)}
  th,td{border-bottom:1px solid var(--line); padding:10px 12px; text-align:center}
  tbody tr:nth-child(odd){background:var(--zebra)}
  td.route, th.route{text-align:left; position:sticky; left:0; background:#fffffff0; z-index:2}
  .dark td.route, .dark th.route{background:rgba(17,24,39,.95)}
  .tier{font-weight:900; padding:6px 10px; border-radius:999px; display:inline-block; min-width:64px}
  .t10{background:rgba(16,185,129,.15); color:var(--good); border:1px solid rgba(16,185,129,.35)}
  .t15{background:rgba(34,197,94,.15); color:var(--ok); border:1px solid rgba(34,197,94,.35)}
  .t20{background:rgba(6,182,212,.15); color:var(--mid); border:1px solid rgba(6,182,212,.35)}
  .t30{background:rgba(245,158,11,.15); color:var(--warn); border:1px solid rgba(245,158,11,.35)}
  .t60{background:rgba(239,68,68,.15); color:var(--meh); border:1px solid rgba(239,68,68,.35)}
  .tBig{background:rgba(107,114,128,.15); color:#cbd5e1; border:1px solid rgba(107,114,128,.4)}
  .badge{background:var(--chip); border:1px solid var(--line); color:var(--chipText); padding:6px 10px; border-radius:8px; font-size:12px; font-weight:700}
  .highlight{animation:flash 1.6s ease}
  @keyframes flash{0%{background:#04785733}100%{background:transparent}}

  /* Modal */
  .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:100}
  .dialog{background:var(--panel); border:1px solid var(--line); border-radius:16px; width:min(90vw,1400px); max-height:85vh; display:flex; flex-direction:column; padding:16px}
  .dialogHeader{flex-shrink:0; display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px}
  .dialog h3{margin:0}
  .dialog pre{display:none}
  .dialogTabs{display:flex;gap:6px;margin-top:12px;border-bottom:1px solid var(--line);padding-bottom:0}
  .dialogTab{background:transparent;border:0;border-bottom:2px solid transparent;color:var(--muted);padding:8px 16px;cursor:pointer;font-weight:600;font-size:13px;transition:all .2s}
  .dialogTab.active{color:var(--accent);border-bottom-color:var(--accent)}
  .dialogTab:hover{color:var(--text)}
  .dialogBody{flex:1; overflow-y:auto; max-height:calc(80vh - 60px); padding-right:8px}
  .tabContent{display:none}
  .tabContent.active{display:block}
  .close{background:transparent; border:1px solid var(--line); color:var(--chipText); border-radius:8px; padding:6px 10px; cursor:pointer}
  .miniBuckets{margin-top:12px}
  .miniBucket{width:100%; border-collapse:collapse; font-size:12px}
  .miniBucket th,.miniBucket td{border-bottom:1px solid var(--line); padding:6px 8px; text-align:left}
  .departuresSection{margin-top:12px}
  .gapTables.twoCols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .gapTables.stack{display:grid;grid-template-columns:1fr;gap:12px}
  .gapTableWrap h5{margin:0 0 4px;font-size:13px;color:var(--chipText)}
  .gapTableScroll{max-height:300px;overflow:auto;border:1px solid var(--line);border-radius:10px}
  .gapTable{width:100%;border-collapse:collapse;font-size:13px;font-family:ui-monospace,monospace}
  .gapTable thead th{position:sticky;top:0;background:#fffffff0;z-index:1}
  .dark .gapTable thead th{background:rgba(17,24,39,.9)}
  .gapTable th,.gapTable td{border-bottom:1px solid var(--line);padding:6px 8px;text-align:left}
  .numCol{width:42px;text-align:right}
  .gapBadge{display:inline-block;border:1px solid var(--line);border-radius:8px;padding:2px 6px}
  .gapWarn{border-color:#f59e0b;color:#f59e0b}
  .gapHigh{background:#ef44441a;border-color:#ef4444;color:#ef4444}

  .serviceWindows{margin-top:16px}
  .serviceWindows h4{margin:0 0 8px;font-size:14px}
  .serviceWindowGrid{display:grid;gap:12px}
  .serviceWindowGrid.dual{grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
  .serviceWindowWrap{border:1px solid var(--line);border-radius:10px;padding:10px;background:rgba(148,163,184,.08)}
  .dark .serviceWindowWrap{background:rgba(15,23,42,.3)}
  .serviceWindowWrap h5{margin:0 0 6px;font-size:13px;color:var(--chipText);text-transform:uppercase;letter-spacing:.03em}
  .serviceWindowEmpty{color:var(--muted);font-size:12px;padding:6px 0}
  .serviceWindowScroll{max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:10px}
  .serviceWindowTable{width:100%;border-collapse:collapse;font-size:12px;font-family:ui-monospace,monospace}
  .serviceWindowTable th,.serviceWindowTable td{border-bottom:1px solid var(--line);padding:6px 8px;text-align:left;vertical-align:top}
  .serviceWindowTable th{background:#fffffff0;position:sticky;top:0;z-index:1}
  .dark .serviceWindowTable th{background:rgba(17,24,39,.9)}
  .exceptionList{font-size:12px;color:var(--muted);line-height:1.4}

  /* Frequency Chart */
  .chartSection{margin:16px 0}
  .chartSection h4{margin:0 0 8px;font-size:14px}
  .chartContainer{border:1px solid var(--line);border-radius:10px;padding:12px;background:rgba(148,163,184,.08)}
  .dark .chartContainer{background:rgba(15,23,42,.3)}
  .chartSvg{width:100%;height:180px}
  .chartAxis{stroke:var(--line);stroke-width:1}
  .chartAxisLabel{fill:var(--muted);font-size:10px}
  .chartLine{fill:none;stroke-width:2}
  .chartDot{r:3}
  .chartBand{opacity:0.15}
  .chartBandPeak{fill:#22c55e}
  .chartBandOffPeak{fill:#94a3b8}
  .chartBandInferred{fill:none;stroke-width:3;opacity:0.6}
  .chartBandInferredPeak{stroke:#22c55e}
  .chartBandInferredBase{stroke:#06b6d4}
  .chartBandInferredOff{stroke:#94a3b8}
  .chartLegend{display:flex;gap:16px;margin-top:8px;font-size:11px;color:var(--muted)}
  .chartLegend span{display:flex;align-items:center;gap:4px}
  .chartLegend .dot{width:10px;height:10px;border-radius:50%}
  .chartWithStats{display:flex;gap:16px;align-items:flex-start}
  .chartWithStats .chartContainer{flex:1}
  .chartWithStats .statsSidebar{flex:0 0 200px;display:flex;flex-direction:column;gap:12px;padding:12px;background:rgba(148,163,184,.08);border:1px solid var(--line);border-radius:10px}
  .dark .chartWithStats .statsSidebar{background:rgba(15,23,42,.3)}
  .statsSidebar .statItem{display:flex;flex-direction:column;gap:4px}
  .statsSidebar .statLabel{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.04em}
  .statsSidebar .statValue{font-size:20px;font-weight:800;color:var(--text)}

  /* Compact Departures */
  .compactDepartures{margin-top:12px}
  .compactDepartures h4{margin:0 0 8px;font-size:14px;cursor:pointer;user-select:none}
  .compactDepartures h4:hover{color:var(--accent)}
  .collapsibleContent{overflow:hidden;transition:max-height 0.3s ease}
  .collapsibleContent.collapsed{max-height:0}
  .hourRow{display:flex;align-items:baseline;margin-bottom:4px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:13px}
  .hourLabel{width:24px;color:var(--muted);font-weight:700;text-align:right;margin-right:4px;flex-shrink:0}
  .hourPipe{color:var(--line);margin-right:8px;font-weight:400}
  .hourMins{color:var(--text);letter-spacing:.5px}
  .directionBlock{margin-bottom:12px}
  .directionBlock h5{margin:0 0 6px;font-size:13px;color:var(--chipText)}

  /* Side-by-side layouts */
  .sideBySide{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:768px){.sideBySide{grid-template-columns:1fr}}

  /* Gap distribution */
  .gapDistribution{margin-top:16px}
  .gapDistribution h4{margin:0 0 8px;font-size:14px}
  .gapDistContainer{border:1px solid var(--line);border-radius:10px;padding:12px;background:rgba(148,163,184,.08)}
  .dark .gapDistContainer{background:rgba(15,23,42,.3)}
  .gapDistTable{width:100%;max-width:400px;border-collapse:collapse;font-size:13px;border:1px solid var(--line);border-radius:10px;font-family:ui-monospace,monospace}
  .gapDistTable th,.gapDistTable td{border-bottom:1px solid var(--line);padding:8px 12px;text-align:left}
  .gapDistTable th{background:#fffffff0}
  .dark .gapDistTable th{background:rgba(17,24,39,.9)}
  .gapDistTable td:last-child{text-align:right}
  .gapDistBars{display:flex;flex-direction:column;gap:8px;max-width:500px}
  .gapDistRow{display:flex;align-items:center;gap:8px;font-size:13px}
  .gapDistLabel{width:70px;color:var(--muted);text-align:right;font-family:ui-monospace,monospace;flex-shrink:0}
  .gapDistBarWrap{flex:1;height:20px;background:var(--line);border-radius:4px;overflow:hidden}
  .gapDistBar{height:100%;border-radius:4px;transition:width 0.3s ease}
  .gapDistBar.tier10{background:#10b981}
  .gapDistBar.tier15{background:#22c55e}
  .gapDistBar.tier20{background:#06b6d4}
  .gapDistBar.tier30{background:#eab308}
  .gapDistBar.tier60{background:#ef4444}
  .gapDistBar.tierBig{background:#6b7280}
  .gapDistCount{width:65px;font-family:ui-monospace,monospace;color:var(--text);flex-shrink:0}

  /* New upload row layout */
  .uploadRow{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .fileBtn{display:flex;align-items:center;gap:8px}
  .fileBtn label{cursor:pointer}
  .fileBtn .btn{background:var(--panel);color:var(--text);border:1px solid var(--line);padding:12px 16px;font-size:14px}
  .fileBtn .btn:hover{background:var(--chip)}
  .dark .fileBtn .btn{background:var(--panel);color:var(--text);border:1px solid var(--line)}
  .dark .fileBtn .btn:hover{background:var(--chip)}
  .btnDemo{background:var(--chip);color:var(--text);border:1px solid var(--line);padding:12px 20px;font-size:14px}
  .btnDemo:hover{background:var(--line)}
  .dark .btnDemo{background:#374151;color:#e5e7eb;border:1px solid #4b5563}
  .dark .btnDemo:hover{background:#4b5563}
  .btnAnalyze{background:#10b981;color:#fff;padding:12px 20px;font-size:14px}
  .btnAnalyze:hover{background:#059669}
  .btnAnalyze:disabled{background:#d1d5db;color:#9ca3af;opacity:.7}
  .dark .btnAnalyze:disabled{background:#374151;color:#6b7280}
  .timeRange{display:flex;align-items:center;gap:8px;color:var(--muted);font-weight:700;font-size:13px;text-transform:uppercase;letter-spacing:.03em}
  .timeRange input[type="time"]{width:100px;padding:10px 12px;border-radius:10px;font-weight:600}
  .daySelector{display:flex;align-items:center;gap:6px}
  .daySelector label{font-size:11px;color:var(--muted);font-weight:700;text-transform:uppercase;letter-spacing:.04em}
  .daySelector select{background:var(--panel);border:1px solid var(--line);color:var(--text);padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .filterRow{display:flex;gap:12px;align-items:stretch;flex-wrap:wrap}
  .dayPills{display:flex;gap:8px;flex-shrink:0}
  .dayPill{background:var(--panel);border:2px solid var(--line);color:var(--text);padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:700;transition:all .2s;min-width:90px;text-align:center}
  .dayPill:hover{border-color:var(--accent)}
  .dayPill.active{background:var(--btn);border-color:var(--btn);color:#fff}
  .dayPillLabel{font-size:10px;font-weight:700;letter-spacing:.04em;opacity:.7;text-transform:uppercase;margin-bottom:2px}
  .dayPillValue{font-size:15px;font-weight:800}
  .filterMessage{margin-top:14px;font-size:13px;color:var(--muted)}
  .filterMessage strong{color:var(--text);font-weight:700}
  .filterBar{display:flex;align-items:center;justify-content:space-between;margin-top:14px}
  .filterBar .search{max-width:300px;background:var(--chip);border:1px solid var(--line)}

  /* Tier summary boxes */
  .tierBoxes{display:flex;gap:10px;flex:1}
  .tierBox{flex:1;border:none;border-radius:10px;padding:12px 8px;text-align:center;cursor:pointer;transition:all .2s;min-width:0}
  .tierBox:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.15)}
  .tierBox.active{box-shadow:0 0 0 3px var(--accent)}
  .tierName{font-size:10px;font-weight:700;letter-spacing:.04em;margin-bottom:2px;color:rgba(255,255,255,.85);text-transform:uppercase}
  .tierCount{font-size:22px;font-weight:900;color:#fff}
  .tier10{background:#10b981}
  .tier15{background:#22c55e}
  .tier20{background:#06b6d4}
  .tier30{background:#eab308}
  .tier60{background:#ef4444}
  .tierBig{background:#6b7280}

  /* Route table new styles */
  .tableHeader{display:flex;justify-content:flex-end;margin-bottom:8px}
  .routeCount{font-size:13px;color:var(--muted);font-weight:500}
  .routeCount strong{color:var(--text);font-weight:700}
  .routeTable{width:100%}
  .routeTable th.dayCol{width:20%}
  .routeTable td.dayCell{font-family:ui-monospace,monospace}
  .routeTable th.numCol{width:60px;text-align:center}
  .routeTable td.numCol{text-align:center;font-family:ui-monospace,monospace;font-size:13px;color:var(--textSecondary)}
  .dayCell .headway{font-weight:700;margin-right:8px}
  .dayCell .tierBadge{font-size:11px;padding:4px 8px;border-radius:6px;font-weight:700}
  .dayCell .noService{color:var(--muted);font-style:italic}

  /* Modal improvements */
  .modalRouteHeader{display:flex;align-items:center;gap:16px;margin-bottom:4px}
  .modalRouteBadge{background:transparent;color:var(--text);font-size:18px;font-weight:900;padding:0}
  .modalDayTabs{display:flex;gap:6px}
  .modalDayTab{background:transparent;border:1px solid var(--line);color:var(--muted);padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:700;font-size:13px;transition:all .2s}
  .modalDayTab.active{background:#6b7280;color:#fff;border-color:#6b7280}
  .modalDayTab:hover{border-color:var(--accent)}

  /* Modal stats cards */
  .statsCards{display:flex;gap:12px;margin-bottom:16px}
  .statCard{background:rgba(148,163,184,.08);border:1px solid var(--line);border-radius:12px;padding:16px;flex:1}
  .dark .statCard{background:rgba(15,23,42,.4)}
  .statCard .label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.05em;margin-bottom:8px}
  .statCard .value{font-size:24px;font-weight:800}
  .statCard .subvalue{font-size:13px;color:var(--muted);margin-top:4px}
  .statCard.tierCard{flex:0 0 auto;min-width:140px}
  .statCard.combinedCard .label{margin-bottom:12px}
  .combinedStats{display:flex;flex-direction:column;gap:8px}
  .combinedRow{display:flex;align-items:center;gap:8px;font-size:14px}
  .combinedRow .statLabel{color:var(--muted);min-width:90px}
  .combinedRow .statValue{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
  .violationBadge{padding:2px 8px;border-radius:4px;font-size:12px;font-weight:600}
  .violationBadge.hard{background:#fecaca;color:#991b1b}
  .dark .violationBadge.hard{background:#7f1d1d;color:#fecaca}
  .violationBadge.grace{background:#fef3c7;color:#92400e}
  .dark .violationBadge.grace{background:#78350f;color:#fef3c7}
  .directionalStats{margin-bottom:16px}
  .directionalStats h4{margin:0 0 12px;font-size:14px;font-weight:700}
  .directionGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .directionCard{background:rgba(148,163,184,.06);border:1px solid var(--line);border-radius:10px;padding:12px}
  .directionHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .dirBadge{padding:4px 10px;border-radius:6px;font-size:12px;font-weight:700;text-transform:uppercase}
  .dirBadge.outbound{background:#06b6d4;color:#fff}
  .dirBadge.inbound{background:#10b981;color:#fff}
  .tripCount{font-size:12px;color:var(--muted)}
  .directionBody{display:flex;flex-direction:column;gap:6px}
  .dirStat{display:flex;justify-content:space-between;font-size:13px}
  .dirStat span{color:var(--muted)}

  /* Chart with two lines */
  .chartLegendDir{display:flex;gap:24px;margin-top:8px;font-size:12px;font-weight:600}
  .chartLegendDir span{display:flex;align-items:center;gap:6px}
  .chartLegendDir .dot{width:12px;height:12px;border-radius:50%}

  @media (max-width:1100px){
    .filterRow{flex-direction:column}
    .tierBoxes{flex-wrap:wrap}
    .tierBox{min-width:calc(33.33% - 8px)}
  }
  @media (max-width:900px){
    .statsCards{flex-direction:column}
    .statCard.tierCard{min-width:100%}
    .directionGrid{grid-template-columns:1fr}
    .tierBox{min-width:calc(33.33% - 8px)}
  }
  @media (max-width:600px){
    .tierBox{min-width:calc(50% - 6px)}
    .uploadRow{flex-direction:column;align-items:stretch}
    .uploadRow>*{width:100%}
    .dayPills{flex-wrap:wrap}
    .dayPill{flex:1;min-width:80px}
    .filterBar{flex-direction:column;gap:12px;align-items:stretch}
    .filterBar .search{width:100%}
    .filterBar .routeCount{text-align:right}
    .combinedRow{flex-direction:column;align-items:flex-start}
    .combinedRow .statLabel{min-width:auto}
  }

  /* Validation column and icons */
  .validCol{width:80px;text-align:center}
  .validIcon{font-size:16px;font-weight:bold;cursor:pointer}
  .validIcon.unverified{color:#9ca3af}
  .validIcon.correct{color:#10b981}
  .validIcon.incorrect{color:#ef4444}
  .validationPanel{margin-top:16px;padding:16px;background:rgba(148,163,184,.08);border:1px solid var(--line);border-radius:10px}
  .validationControls{display:flex;flex-direction:column;gap:12px}
  .validationControls label{font-size:12px;font-weight:700;color:var(--muted);text-transform:uppercase}
  .validationControls select,.validationControls textarea{padding:8px;border:1px solid var(--line);border-radius:8px;background:var(--panel);color:var(--text)}
  .validationMeta{margin-top:12px;padding-top:12px;border-top:1px solid var(--line)}

  /* Feed metadata */
  .feedMeta{margin-top:12px;padding:12px;background:rgba(148,163,184,.08);border:1px solid var(--line);border-radius:10px;font-size:13px}
  .feedMeta div{margin-bottom:4px}
  .feedMeta div:last-child{margin-bottom:0}
  .feedMeta strong{color:var(--text);font-weight:700}

  /* Historical data banner */
  .historicalBanner{margin-top:12px;padding:12px;background:rgba(245,158,11,.15);border:1px solid rgba(245,158,11,.4);border-radius:10px;font-size:13px;color:#b45309}
  .dark .historicalBanner{color:#fbbf24}

  /* Lineage panel */
  .lineagePanel{margin-top:16px;padding:16px;background:rgba(59,130,246,.08);border:1px solid rgba(59,130,246,.3);border-radius:10px}
  .lineagePanel h4{margin:0 0 12px;font-size:14px;color:var(--accent)}
  .lineageControls{display:flex;flex-direction:column;gap:12px}
  .lineageControls label{font-size:12px;font-weight:700;color:var(--muted);text-transform:uppercase}
  .lineageControls input[type="text"],.lineageControls textarea{padding:8px;border:1px solid var(--line);border-radius:8px;background:var(--panel);color:var(--text)}
  .lineageControls .checkboxLabel{display:flex;align-items:center;gap:8px;font-size:13px;font-weight:normal;text-transform:none;cursor:pointer}
  .lineageControls input[type="checkbox"]{width:18px;height:18px;accent-color:var(--accent)}

  /* Route change checkboxes */
  .changeTypeOptions{display:flex;flex-direction:column;gap:4px;margin-top:8px}
  .checkboxOption{display:flex;align-items:center;gap:8px;padding:8px;border-radius:6px;cursor:pointer;transition:background .2s}
  .checkboxOption:hover{background:rgba(59,130,246,.1)}
  .checkboxOption input[type="checkbox"]{margin:0;cursor:pointer;width:16px;height:16px;accent-color:var(--accent)}
  .checkboxText{font-size:13px;color:var(--text);font-weight:400}
  .helpText{font-size:13px;color:var(--muted);margin-bottom:8px}

  /* Data source controls */
  .dataSourceGroup{margin-top:12px;padding-top:12px;border-top:1px solid var(--line)}
  .dataSourceRadios{display:flex;gap:16px;margin-top:4px}
  .dataSourceRadios label{display:flex;align-items:center;gap:6px;font-size:13px;font-weight:normal;text-transform:none;cursor:pointer}
  #sourceNotesDiv{margin-top:8px}

  /* Tier Reference Legend */
  .tierReference{
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
    padding: 12px;
    background: rgba(148,163,184,.06);
    border-radius: 8px;
    margin-bottom: 16px;
    border: 1px solid var(--line);
  }
  .tierItem{
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .tierBadgeLegend{
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 700;
    min-width: 40px;
    text-align: center;
    color: #fff;
  }
  .tierDesc{
    font-size: 12px;
    color: var(--muted);
    white-space: nowrap;
  }
  .tierNote{
    width: 100%;
    font-size: 11px;
    color: var(--muted);
    font-style: italic;
    margin-top: 4px;
  }

  /* Manual Override Section */
  .overrideSection{
    margin-bottom: 12px;
    padding: 12px;
    background: rgba(59,130,246,.08);
    border: 1px solid rgba(59,130,246,.3);
    border-radius: 8px;
  }
  .overrideLabel{
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    text-transform: none;
  }
  .overrideLabel input[type="checkbox"]{
    width: 18px;
    height: 18px;
    accent-color: var(--accent);
  }
  .tierSelect{
    width: 100%;
    padding: 8px;
    border: 1px solid var(--line);
    border-radius: 8px;
    background: var(--panel);
    color: var(--text);
    margin-top: 4px;
  }
  .overrideIndicator{
    display: inline-block;
    font-size: 10px;
    color: var(--muted);
    font-style: italic;
    margin-left: 4px;
  }

  /* 4-column stats row: Frequency | Analysis | Outbound | Inbound */
  .statsRow{
    display: grid;
    grid-template-columns: 160px 1fr 180px 180px;
    gap: 12px;
    margin-bottom: 16px;
  }
  .statsRow .statCard{
    padding: 12px;
    margin: 0;
  }
  .statsRow .frequencyCard{
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .statsRow .frequencyCard .freqHeader{
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .statsRow .frequencyCard .freqBadge{
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    color: #fff;
  }
  .statsRow .frequencyCard .freqBadge.tier10{background:#10b981}
  .statsRow .frequencyCard .freqBadge.tier15{background:#22c55e}
  .statsRow .frequencyCard .freqBadge.tier20{background:#06b6d4}
  .statsRow .frequencyCard .freqBadge.tier30{background:#eab308}
  .statsRow .frequencyCard .freqBadge.tier60{background:#ef4444}
  .statsRow .frequencyCard .freqBadge.tierBig{background:#6b7280}
  .statsRow .frequencyCard .freqThreshold{
    font-size: 11px;
    color: var(--muted);
  }
  .statsRow .frequencyCard .freqStatRow{
    display: flex;
    justify-content: space-between;
    font-size: 12px;
  }
  .statsRow .frequencyCard .freqStatRow span{
    color: var(--muted);
  }
  .tierLegend .tierExplain{
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .tierLegend .tierExplain .tierBadgeSmall{
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 9px;
    font-weight: 700;
    color: #fff;
  }
  .tierBadgeSmall.t10, .tierBadgeSmall.tier10{background:#10b981}
  .tierBadgeSmall.t15, .tierBadgeSmall.tier15{background:#22c55e}
  .tierBadgeSmall.t20, .tierBadgeSmall.tier20{background:#06b6d4}
  .tierBadgeSmall.t30, .tierBadgeSmall.tier30{background:#eab308}
  .tierBadgeSmall.t60, .tierBadgeSmall.tier60{background:#ef4444}
  .tierBadgeSmall.tBig, .tierBadgeSmall.tierBig{background:#6b7280}
  .tierLegend .tierExplain .tierThreshold{
    font-size: 10px;
    color: var(--muted);
  }
  .tierLegend .tierNote{
    font-size: 9px;
    color: var(--muted);
    font-style: italic;
  }
  .statsRow .analysisCard .combinedStats{
    font-size: 13px;
  }
  .statsRow .analysisCard .combinedRow{
    margin-bottom: 4px;
  }
  .statsRow .dirCard{
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .statsRow .dirCard .dirHeader{
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .statsRow .dirCard .dirBadgeSmall{
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    color: #fff;
  }
  .statsRow .dirCard .dirBadgeSmall.outbound{background:#06b6d4}
  .statsRow .dirCard .dirBadgeSmall.inbound{background:#10b981}
  .statsRow .dirCard .tripCountSmall{
    font-size: 11px;
    color: var(--muted);
  }
  .statsRow .dirCard .dirStatRow{
    display: flex;
    justify-content: space-between;
    font-size: 12px;
  }
  .statsRow .dirCard .dirStatRow span{
    color: var(--muted);
  }
  @media (max-width:900px){
    .statsRow{
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .statsRow .analysisCard{
      grid-column: span 3;
    }
    .statsRow .frequencyCard{
      grid-column: span 1;
    }
  }
  @media (max-width:600px){
    .statsRow{
      grid-template-columns: 1fr 1fr;
    }
    .statsRow .analysisCard{
      grid-column: span 2;
    }
    .statsRow .frequencyCard,
    .statsRow .dirCard{
      grid-column: span 1;
    }
  }

  /* Modal grid layout with sidebar */
  .modalGrid{
    display: grid;
    grid-template-columns: 1fr 280px;
    gap: 16px;
    align-items: start;
  }
  .modalMain{
    min-width: 0;
  }
  .modalSidebar{
    display: flex;
    flex-direction: column;
    gap: 12px;
    position: sticky;
    top: 20px;
  }
  .modalSidebar .validationPanel,
  .modalSidebar .lineagePanel{
    margin: 0;
    padding: 12px;
  }
  .modalSidebar .validationPanel h4,
  .modalSidebar .lineagePanel h4{
    margin: 0 0 10px;
    font-size: 13px;
  }
  .modalSidebar .validationControls{
    gap: 8px;
  }
  .modalSidebar .validationControls label{
    font-size: 11px;
  }
  .modalSidebar .validationControls select,
  .modalSidebar .validationControls textarea,
  .modalSidebar .lineageControls input,
  .modalSidebar .lineageControls textarea{
    padding: 6px;
    font-size: 12px;
  }
  .modalSidebar .btn{
    padding: 8px 12px;
    font-size: 12px;
  }
  @media (max-width:900px){
    .modalGrid{
      grid-template-columns: 1fr;
    }
    .modalSidebar{
      order: 10;
    }
  }

  /* Side-by-side charts and gap distribution */
  .chartsRow{
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
    align-items: end;
  }
  .chartsRow .chartSection{
    margin: 0;
  }
  .chartsRow .gapDistribution{
    margin: 0;
  }
  @media (max-width:900px){
    .chartsRow{
      grid-template-columns: 1fr;
    }
  }

  /* Toggle buttons for route changes */
  .changeButtons{
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  .changeBtn{
    padding: 6px 10px;
    border: 1px solid var(--line);
    border-radius: 6px;
    background: var(--panel);
    color: var(--text);
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .changeBtn:hover{
    background: rgba(59,130,246,.1);
    border-color: #3b82f6;
  }
  .changeBtn.active{
    background: #3b82f6;
    color: white;
    border-color: #3b82f6;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üöå GTFS Frequency Screener</h1>
      <button id="theme" class="btn btnTheme" type="button" title="Toggle theme">üåô</button>
    </header>

    <section id="controlsPanel" class="panel">
      <div class="uploadRow">
        <div class="fileBtn">
          <label for="gtfs" class="btn">üìÅ Select GTFS Zip...</label>
          <input id="gtfs" type="file" accept=".zip" style="display:none">
          <span id="fname" class="fileName"></span>
        </div>
        <button id="demo" class="btn btnDemo" type="button">DEMO</button>
        <div class="timeRange">
          <span>TIME</span>
          <input id="t0" type="time" value="07:00">
          <span>‚Äî</span>
          <input id="t1" type="time" value="22:00">
        </div>
        <button id="go" class="btn btnAnalyze" type="button" disabled>üìä ANALYZE</button>
        <button id="exportBtn" class="btn" style="display:none" onclick="exportResults()">üíæ Export Results</button>
      </div>
      <div id="rangeMessage" class="rangeMessage" role="status" aria-live="polite"></div>
      <!-- Hidden merge checkbox - default on -->
      <input id="merge" type="checkbox" checked style="display:none">
      <div id="feedMetadata" class="feedMeta" style="display:none">
        <div><strong>Feed:</strong> <span id="feedFilename"></span></div>
        <div><strong>Valid:</strong> <span id="feedValidity"></span></div>
        <div><strong>Analyzed:</strong> <span id="analyzedTime"></span></div>
      </div>
      <div id="historicalBanner" class="historicalBanner" style="display:none"></div>
    </section>

    <!-- Day Pills + Tier Summary Boxes -->
    <section id="tierSummary" class="panel" style="display:none">
      <div class="filterRow">
        <div class="dayPills">
          <button class="dayPill active" data-day="Weekday" type="button">
            <div class="dayPillLabel">SORTING BY</div>
            <div class="dayPillValue">Weekday</div>
          </button>
          <button class="dayPill" data-day="Saturday" type="button">
            <div class="dayPillLabel">SATURDAY</div>
            <div class="dayPillValue">Select</div>
          </button>
          <button class="dayPill" data-day="Sunday" type="button">
            <div class="dayPillLabel">SUNDAY</div>
            <div class="dayPillValue">Select</div>
          </button>
        </div>
        <div class="tierBoxes">
          <button class="tierBox tier10" data-tier="10" type="button">
            <div class="tierName">FREQ+</div>
            <div class="tierCount">0</div>
          </button>
          <button class="tierBox tier15" data-tier="15" type="button">
            <div class="tierName">FREQ</div>
            <div class="tierCount">0</div>
          </button>
          <button class="tierBox tier20" data-tier="20" type="button">
            <div class="tierName">GOOD</div>
            <div class="tierCount">0</div>
          </button>
          <button class="tierBox tier30" data-tier="30" type="button">
            <div class="tierName">BASIC</div>
            <div class="tierCount">0</div>
          </button>
          <button class="tierBox tier60" data-tier="60" type="button">
            <div class="tierName">INFREQ</div>
            <div class="tierCount">0</div>
          </button>
          <button class="tierBox tierBig" data-tier=">60" type="button">
            <div class="tierName">SPARSE</div>
            <div class="tierCount">0</div>
          </button>
        </div>
      </div>
      <div class="filterMessage">
        Showing all routes for <strong id="sortDayLabel">Weekday</strong>. Click a frequency box above to filter.
      </div>
      <div class="filterBar">
        <div class="search">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-opacity=".5" stroke-width="2" d="m21 21-4.35-4.35M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16Z"/></svg>
          <input id="q" placeholder="Filter by route name...">
        </div>
        <span class="routeCount">Displaying <strong>0</strong> routes</span>
      </div>
    </section>

    <!-- Route List Table -->
    <section id="tableWrap" class="panel" style="display:none">
      <div id="resultsScroll" class="resultsScroll">
        <table id="tbl" class="routeTable">
          <thead>
            <tr>
              <th class="route">ROUTE</th>
              <th class="dayCol">WEEKDAY</th>
              <th class="dayCol">SATURDAY</th>
              <th class="dayCol">SUNDAY</th>
              <th class="numCol">TRIPS</th>
              <th class="numCol">BEST</th>
              <th class="numCol">WORST</th>
              <th class="validCol">VALIDATED</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </div>

  <!-- Inspect Modal -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="dialog">
      <div class="dialogHeader">
        <div id="modalTitle"></div>
        <button class="close" onclick="closeModal()">‚úï</button>
      </div>
      <div id="modalBody" class="dialogBody"></div>
    </div>
  </div>

<script>
let RAW_ROWS = []; // {route, dir, day, b, avg, tier, hw:[], times:[], dirDetails:{'0':{times:[],tier},'1':{...}} }
let ROUTE_DATA = {}; // {routeName: {Weekday: rowData, Saturday: rowData, Sunday: rowData}}
let activeTierFilter = null;
let VALIDATIONS = {}; // {route: {day: {status, notes, verifiedAt, expectedTier, data_source, source_notes}}}
let ROUTE_LINEAGE = {}; // {route: {stable_id, comparable_to_previous, notes}}
window.FEED_INFO = null;
window.ANALYZED_AT = null;
window.IS_HISTORICAL_DATA = false; // True if feed dates are in the past

const fileEl = document.getElementById('gtfs');
const btn = document.getElementById('go');
const fname = document.getElementById('fname');

// File selection via label click
fileEl.addEventListener('change', ()=>{
  btn.disabled = !(fileEl.files && fileEl.files.length>0);
  fname.textContent = fileEl.files?.[0]?.name || '';
});
btn.addEventListener('click', analyze);

// Demo button
document.getElementById('demo').addEventListener('click', loadDemo);

async function loadDemo(){
  // For demo, we'll show an alert - implement with actual demo data if available
  alert('Demo mode: Upload a GTFS ZIP file to analyze transit frequency.');
}

function setupResultsSizing(){
  updateResultsMaxHeight();
  window.addEventListener('resize', updateResultsMaxHeight);
}

if(document.readyState==='loading'){
  document.addEventListener('DOMContentLoaded', setupResultsSizing);
}else{
  setupResultsSizing();
}

// theme
document.getElementById('theme').addEventListener('click', toggleTheme);
(function initTheme(){
  const saved=localStorage.getItem('theme')||'light';
  if(saved==='dark') document.body.classList.add('dark');
  const themeBtn = document.getElementById('theme');
  themeBtn.textContent = document.body.classList.contains('dark') ? 'üåô' : '‚òÄÔ∏è';
})();
function toggleTheme(){
  document.body.classList.toggle('dark');
  const themeBtn = document.getElementById('theme');
  themeBtn.textContent = document.body.classList.contains('dark') ? 'üåô' : '‚òÄÔ∏è';
  localStorage.setItem('theme', document.body.classList.contains('dark')?'dark':'light');
}

// Validation functions
function loadValidations(){
  const saved = localStorage.getItem('gtfs-validations');
  if(saved) VALIDATIONS = JSON.parse(saved);
}

// Route lineage functions
function loadRouteLineage(){
  const saved = localStorage.getItem('gtfs-route-lineage');
  if(saved) ROUTE_LINEAGE = JSON.parse(saved);
}

function saveRouteLineage(){
  localStorage.setItem('gtfs-route-lineage', JSON.stringify(ROUTE_LINEAGE));
}

function getRouteLineage(route){
  return ROUTE_LINEAGE[route] || {stable_id: '', route_changes: {changes: [], comparable_to_previous: true, notes: ''}};
}

function setRouteLineage(route, lineage){
  ROUTE_LINEAGE[route] = {
    stable_id: lineage.stable_id || '',
    route_changes: {
      changes: lineage.route_changes?.changes || [],
      comparable_to_previous: lineage.route_changes?.comparable_to_previous !== false,
      notes: lineage.route_changes?.notes || ''
    }
  };
  saveRouteLineage();
}

// Route change type definitions
const CHANGE_TYPES = [
  {value: 'rerouted', label: 'Rerouted (different streets/corridor)'},
  {value: 'extended', label: 'Extended (added stops at end(s))'},
  {value: 'shortened', label: 'Shortened (removed stops)'},
  {value: 'merged', label: 'Merged with another route'},
  {value: 'split', label: 'Split into multiple routes'},
  {value: 'number-changed', label: 'Route number changed (same corridor)'},
  {value: 'frequency-only', label: 'Service frequency changed only'},
  {value: 'discontinued', label: 'Discontinued/eliminated'},
  {value: 'new-route', label: 'New route (first time analyzing)'}
];

const GEOGRAPHIC_CHANGES = ['rerouted', 'merged', 'split', 'shortened', 'discontinued', 'new-route'];

function buildChangeTypeCheckboxes(selectedChanges){
  return `<div class="changeButtons">
    ${CHANGE_TYPES.map(ct => `
      <button type="button" class="changeBtn ${selectedChanges.includes(ct.value) ? 'active' : ''}" data-change="${ct.value}" onclick="this.classList.toggle('active')">
        ${ct.label}
      </button>
    `).join('')}
  </div>`;
}

function determineComparability(selectedChanges){
  const hasGeographicChange = selectedChanges.some(c => GEOGRAPHIC_CHANGES.includes(c));
  return !hasGeographicChange;
}

// Historical data detection
function detectHistoricalData(){
  if(!FEED_INFO?.validTo) return false;
  const validTo = parseFeedDate(FEED_INFO.validTo);
  if(!validTo) return false;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  return validTo < today;
}

function parseFeedDate(dateStr){
  if(!dateStr) return null;
  // GTFS dates are typically YYYYMMDD format
  if(/^\d{8}$/.test(dateStr)){
    const year = parseInt(dateStr.substr(0, 4), 10);
    const month = parseInt(dateStr.substr(4, 2), 10) - 1;
    const day = parseInt(dateStr.substr(6, 2), 10);
    return new Date(year, month, day);
  }
  // Try standard date parsing
  const parsed = new Date(dateStr);
  return isNaN(parsed.getTime()) ? null : parsed;
}

function saveValidation(){
  const route = currentModalRoute;
  const day = currentModalDay;
  const status = document.getElementById('validationStatus').value;
  const notes = document.getElementById('validationNotes').value;
  const expectedTier = document.getElementById('expectedTier')?.value;
  const dataSource = document.getElementById('dataSourceManual')?.checked ? 'manual' : 'gtfs';
  const sourceNotes = document.getElementById('sourceNotes')?.value || '';

  // Check for manual override
  const hasOverride = document.getElementById('manualOverride')?.checked;
  const manualTier = document.getElementById('manualTier')?.value;
  const overrideReason = document.getElementById('overrideReason')?.value || '';

  if(hasOverride && !manualTier){
    alert('Please select a tier for manual override');
    return;
  }

  if(!VALIDATIONS[route]) VALIDATIONS[route] = {};
  VALIDATIONS[route][day] = {
    status,
    notes,
    verifiedAt: new Date().toISOString(),
    expectedTier: status === 'incorrect' ? expectedTier : null,
    data_source: dataSource,
    source_notes: dataSource === 'manual' ? sourceNotes : ''
  };

  // Add manual override if checked
  if(hasOverride && manualTier){
    VALIDATIONS[route][day].manual_override = {
      tier: manualTier,
      reason: overrideReason
    };
  }

  localStorage.setItem('gtfs-validations', JSON.stringify(VALIDATIONS));
  render(); // Refresh table to show new validation status
  renderModalContent(); // Refresh modal to show updated validation
  alert('Validation saved!');
}

function saveLineage(){
  const route = currentModalRoute;
  const stableId = document.getElementById('lineageStableId')?.value || '';

  // Get all selected route changes (from toggle buttons)
  const selectedChanges = Array.from(
    document.querySelectorAll('.changeBtn.active')
  ).map(btn => btn.dataset.change);

  const changeNotes = document.getElementById('routeChangeNotes')?.value || '';

  // Determine comparability based on change types
  const comparable = determineComparability(selectedChanges);

  setRouteLineage(route, {
    stable_id: stableId,
    route_changes: {
      changes: selectedChanges,
      comparable_to_previous: comparable,
      notes: changeNotes
    }
  });
  alert('Lineage metadata saved!');
}

function getValidationIcon(route, day){
  const v = VALIDATIONS[route]?.[day];
  if(!v || v.status === 'unverified') return '<span class="validIcon unverified" title="Not verified">?</span>';
  if(v.status === 'correct') return '<span class="validIcon correct" title="Verified correct">‚úì</span>';
  if(v.status === 'incorrect') return '<span class="validIcon incorrect" title="Verified incorrect">‚úó</span>';
  return '<span class="validIcon unverified" title="Not verified">?</span>';
}

function toggleExpectedTierDiv(){
  const status = document.getElementById('validationStatus').value;
  const div = document.getElementById('incorrectTierDiv');
  if(div) div.style.display = status === 'incorrect' ? 'block' : 'none';
}

function toggleSourceNotes(){
  const manualRadio = document.getElementById('dataSourceManual');
  const div = document.getElementById('sourceNotesDiv');
  if(div) div.style.display = manualRadio?.checked ? 'block' : 'none';
}

function toggleManualOverride(){
  const checkbox = document.getElementById('manualOverride');
  const selectDiv = document.getElementById('manualTierSelect');
  if(selectDiv){
    selectDiv.style.display = checkbox?.checked ? 'block' : 'none';
  }

  // If unchecking, clear selections
  if(!checkbox?.checked){
    const tierSelect = document.getElementById('manualTier');
    const reasonTextarea = document.getElementById('overrideReason');
    if(tierSelect) tierSelect.value = '';
    if(reasonTextarea) reasonTextarea.value = '';
  }
}

// Load validations and lineage on page load
loadValidations();
loadRouteLineage();

// Day pill clicks
let currentSortDay = 'Weekday';
document.querySelectorAll('.dayPill').forEach(pill => {
  pill.addEventListener('click', () => {
    const day = pill.dataset.day;
    currentSortDay = day;

    // Update active state
    document.querySelectorAll('.dayPill').forEach(p => {
      p.classList.remove('active');
      const label = p.querySelector('.dayPillLabel');
      const value = p.querySelector('.dayPillValue');
      if(p.dataset.day === day){
        p.classList.add('active');
        label.textContent = 'SORTING BY';
        value.textContent = day;
      } else {
        label.textContent = p.dataset.day.toUpperCase();
        value.textContent = 'Select';
      }
    });

    // Update filter message
    const sortDayLabel = document.getElementById('sortDayLabel');
    if(sortDayLabel) sortDayLabel.textContent = day;

    render();
  });
});

// Merge checkbox (hidden but still functional)
const mergeCheckbox = document.getElementById('merge');
if(mergeCheckbox) mergeCheckbox.addEventListener('change', render);

// Search input
document.getElementById('q').addEventListener('input', render);

// Tier box click handlers
document.querySelectorAll('.tierBox').forEach(box => {
  box.addEventListener('click', () => {
    const tier = box.dataset.tier;
    if(activeTierFilter === tier){
      // Deselect
      activeTierFilter = null;
      box.classList.remove('active');
    } else {
      // Select this tier
      document.querySelectorAll('.tierBox').forEach(b => b.classList.remove('active'));
      activeTierFilter = tier;
      box.classList.add('active');
    }
    render();
  });
});

function t2m(s){const p=(s||'').split(':');if(p.length<2)return null;return (+p[0])*60+(+p[1]);}
function m2t(m){const h=Math.floor(m/60); const mm=String(m%60).padStart(2,'0'); return `${String(h).padStart(2,'0')}:${mm}`;}
function parseCsv(text){
  return new Promise(res=>Papa.parse(text,{header:true,skipEmptyLines:true,complete:r=>{
    const clean=r.data.filter(row=>Object.values(row).some(v=>v&&String(v).trim()!==''));res(clean);
  }}));
}
function bucketCounts(headways){
  const b={'‚â§10':0,'11‚Äì15':0,'16‚Äì20':0,'21‚Äì30':0,'31‚Äì60':0,'>60':0};
  for(const h of headways){
    if(h<=10)b['‚â§10']++;
    else if(h<=15)b['11‚Äì15']++;
    else if(h<=20)b['16‚Äì20']++;
    else if(h<=30)b['21‚Äì30']++;
    else if(h<=60)b['31‚Äì60']++;
    else b['>60']++;
  }
  return b;
}
// STRICT grace: at most 2 gaps where T < h ‚â§ T+5; any h > T+5 fails immediately.
function leastWorstTier(headways){
  const tiers=[10,15,20,30,60,Infinity];
  const GRACE=5, MAX_GRACE_COUNT=2;
  for(const T of tiers){
    if(T===Infinity) return '>60';
    let graceCount=0;
    let fail=false;
    for(const h of headways){
      if(h<=T) continue;
      if(h<=T+GRACE){
        graceCount++;
        if(graceCount>MAX_GRACE_COUNT){ fail=true; break; }
      }else{ // strictly beyond grace
        fail=true; break;
      }
    }
    if(!fail) return String(T);
  }
  return '>60';
}
function directionLabel(dir){
  const merge = document.getElementById('merge').checked;
  if(merge) return '‚Äì';
  if(String(dir)==='0') return 'Outbound';
  if(String(dir)==='1') return 'Inbound';
  return String(dir||'‚Äì');
}
function computeMedian(hw){
  if(!hw.length) return 0;
  const sorted=[...hw].sort((a,b)=>a-b);
  const mid=Math.floor(sorted.length/2);
  return (sorted.length%2===1) ? sorted[mid] : (sorted[mid-1]+sorted[mid])/2;
}
function computeMode(hw){
  if(!hw.length) return 0;
  const counts=new Map();
  for(const h of hw) counts.set(h,(counts.get(h)||0)+1);
  let best=hw[0], bestCount=0;
  for(const [val,c] of counts.entries()){
    if(c>bestCount || (c===bestCount && val<best)){ best=val; bestCount=c; }
  }
  return best;
}
function formatGroupedGaps(hw){
  const top=[...hw].sort((a,b)=>b-a).slice(0,10);
  const m=new Map(); for(const h of top) m.set(h,(m.get(h)||0)+1);
  return [...m.entries()].sort((a,b)=>b[0]-a[0]).map(([gap,count])=>`${gap} min (√ó${count})`);
}
function tierThreshold(tier){ const n=parseInt(tier,10); return Number.isFinite(n)?n:Infinity; }
function gapHighlightClass(gap, tier){
  const T=tierThreshold(tier); if(!Number.isFinite(T)) return '';
  if(gap>T+5) return 'gapHigh'; if(gap>T) return 'gapWarn'; return '';
}
// Count violations: gaps that exceed tier threshold + grace period (5 min)
function countViolations(gaps, tier){
  const T = tierThreshold(tier);
  if(!Number.isFinite(T) || !gaps || !gaps.length) return { hard: 0, grace: 0 };
  let hard = 0;  // gaps > T + 5 (fail immediately)
  let grace = 0; // gaps > T but <= T + 5 (within grace)
  for(const g of gaps){
    if(g > T + 5) hard++;
    else if(g > T) grace++;
  }
  return { hard, grace };
}
function renderGapCell(gap, tier){
  if(gap==null) return '‚Äî';
  const cls=gapHighlightClass(gap, tier);
  const classes=['gapBadge']; if(cls) classes.push(cls);
  return `<span class="${classes.join(' ')}">${gap}</span>`;
}

function round1(n){ return Math.round(n*10)/10; }
function formatHeadway(value){
  if(value==null || Number.isNaN(value)) return '‚Äî';
  const rounded=round1(value);
  return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
}
function formatDuration(mins){
  if(mins==null || !Number.isFinite(mins) || mins<=0) return '‚Äî';
  const total=Math.round(mins);
  const h=Math.floor(total/60);
  const m=total%60;
  const parts=[];
  if(h>0) parts.push(`${h}h`);
  if(m>0 || !parts.length) parts.push(`${m}m`);
  return parts.join(' ');
}
function formatDelta(diff){
  if(diff==null || !Number.isFinite(diff) || diff===0) return '¬±0';
  const abs=round1(Math.abs(diff));
  const value=Number.isInteger(abs)?String(abs):abs.toFixed(1);
  return `${diff>0?'+':'‚àí'}${value}`;
}

function deriveServiceWindows(times, opts={}){
  const tolerance=Number.isFinite(opts.tolerance)?opts.tolerance:2;
  const minPairs=Number.isFinite(opts.minPairs)?opts.minPairs:2;
  if(!Array.isArray(times) || times.length<2) return [];
  const sorted=[...times].sort((a,b)=>a-b);
  let current=null;
  const segments=[];

  function finalize(){
    if(!current) return;
    const pairs=current.pairs;
    if(pairs.length>=minPairs){
      const gaps=pairs.map(p=>p.gap);
      const median=computeMedian(gaps);
      const avg=gaps.reduce((a,b)=>a+b,0)/gaps.length;
      const mode=computeMode(gaps);
      const lower=median - tolerance;
      const upper=median + tolerance;
      const outliers=[];
      for(const pair of pairs){
        const gap=pair.gap;
        if(gap<lower || gap>upper){
          outliers.push({start:pair.start,end:pair.end,gap,diff:gap-median});
        }
      }
      segments.push({
        start:current.start,
        end:current.last,
        duration:Math.max(0,current.last-current.start),
        departures:pairs.length+1,
        avg,
        median,
        mode,
        typical:median,
        minGap:Math.min(...gaps),
        maxGap:Math.max(...gaps),
        outliers
      });
    }
    current=null;
  }

  for(let i=1;i<sorted.length;i++){
    const prev=sorted[i-1];
    const curr=sorted[i];
    if(prev==null || curr==null) continue;
    const gap=curr-prev;
    if(!Number.isFinite(gap)) continue;
    if(gap<5 || gap>240){
      finalize();
      continue;
    }
    if(!current){
      current={start:prev,last:curr,pairs:[{start:prev,end:curr,gap}]};
      continue;
    }
    const existingGaps=current.pairs.map(p=>p.gap);
    const typical=computeMedian(existingGaps);
    if(Math.abs(gap-typical)<=tolerance){
      current.pairs.push({start:prev,end:curr,gap});
      current.last=curr;
    }else{
      finalize();
      current={start:prev,last:curr,pairs:[{start:prev,end:curr,gap}]};
    }
  }
  finalize();
  return segments;
}

function mergeRows(rows){
  // merge by route+day using real headways and preserving per-direction times
  const m = new Map();
  for(const r of rows){
    const key = `${r.route}::${r.day}`;
    if(!m.has(key)) m.set(key,{route:r.route, day:r.day, dir:'‚Äì', hw:[], times:[], dirDetails:{'0':{times:[],gaps:[],tier:null}, '1':{times:[],gaps:[],tier:null}}});
    const obj=m.get(key);
    obj.hw = obj.hw.concat(r.hw);
    obj.times = obj.times.concat(r.times);
    // stash per-direction times and gaps for modal
    if(r.dir==='0' || r.dir===0){
      obj.dirDetails['0'].times = obj.dirDetails['0'].times.concat(r.times);
      obj.dirDetails['0'].gaps = obj.dirDetails['0'].gaps.concat(r.hw);
      obj.dirDetails['0'].tier = r.tier;
    }
    if(r.dir==='1' || r.dir===1){
      obj.dirDetails['1'].times = obj.dirDetails['1'].times.concat(r.times);
      obj.dirDetails['1'].gaps = obj.dirDetails['1'].gaps.concat(r.hw);
      obj.dirDetails['1'].tier = r.tier;
    }
  }
  const out=[];
  for(const [,v] of m.entries()){
    v.hw.sort((a,b)=>a-b);
    const b = bucketCounts(v.hw);
    const avg = v.hw.length ? Math.round(v.hw.reduce((a,b)=>a+b,0)/v.hw.length) : 0;
    const best = computeMedian(v.hw);
    const tier = leastWorstTier(v.hw);
    const mergedTimes=v.times.sort((a,b)=>a-b);
    const dedupTimes=[]; for(const t of mergedTimes){ if(!dedupTimes.length || dedupTimes[dedupTimes.length-1]!==t) dedupTimes.push(t); }

    // Process each direction: clean times, calculate gaps with time info
    for(const dirKey of Object.keys(v.dirDetails)){
      const dirTimes=v.dirDetails[dirKey]?.times||[];
      dirTimes.sort((a,b)=>a-b);
      const cleaned=[];
      for(const t of dirTimes){ if(!cleaned.length || cleaned[cleaned.length-1]!==t) cleaned.push(t); }
      v.dirDetails[dirKey].times=cleaned;

      // Calculate gaps with time info for this direction
      const gapsWithTime = [];
      for(let i = 1; i < cleaned.length; i++){
        const gap = cleaned[i] - cleaned[i-1];
        if(gap >= 5 && gap <= 240){
          gapsWithTime.push({ gap, time: cleaned[i-1] });
        }
      }
      v.dirDetails[dirKey].gapsWithTime = gapsWithTime;
      v.dirDetails[dirKey].gaps = gapsWithTime.map(g => g.gap);
    }

    // Find max gap location across all directions
    let maxGapInfo = null;
    for(const dirKey of Object.keys(v.dirDetails)){
      const gapsWithTime = v.dirDetails[dirKey].gapsWithTime || [];
      for(const g of gapsWithTime){
        if(!maxGapInfo || g.gap > maxGapInfo.gap){
          maxGapInfo = { gap: g.gap, direction: dirKey, time: g.time };
        }
      }
    }

    out.push({route:v.route, dir:'‚Äì', day:v.day, b, avg, best, tier, hw:v.hw, times:dedupTimes, dirDetails:v.dirDetails, maxGapInfo});
  }
  return out;
}
function cloneRow(r){
  return {route:r.route, dir:r.dir, day:r.day, b:structuredClone?r.b:JSON.parse(JSON.stringify(r.b)), avg:r.avg, best:r.best, tier:r.tier, hw:[...r.hw], times:[...r.times], dirDetails:cloneDirDetails(r.dirDetails), maxGapInfo:r.maxGapInfo ? {...r.maxGapInfo} : null};
}

// Analyze
async function analyze(){
  const file=fileEl.files[0]; if(!file) return;
  const rangeMessage=document.getElementById('rangeMessage');
  if(rangeMessage) rangeMessage.textContent='';

  const t0=t2m(document.getElementById('t0').value);
  const t1=t2m(document.getElementById('t1').value);
  if(t0==null || t1==null || t0>t1){
    const msg='Enter a valid time range where start is before end.';
    if(rangeMessage){
      rangeMessage.textContent=msg;
    }else{
      alert(msg);
    }
    return;
  }

  const zip=await JSZip.loadAsync(file);
  const need=['routes.txt','trips.txt','stop_times.txt','calendar.txt'];
  for(const n of need){ if(!zip.file(n)) { alert(n+' missing'); return; } }

  const [routes,trips,stopTimes,calendar]=await Promise.all([
    parseCsv(await zip.file('routes.txt').async('text')),
    parseCsv(await zip.file('trips.txt').async('text')),
    parseCsv(await zip.file('stop_times.txt').async('text')),
    parseCsv(await zip.file('calendar.txt').async('text')),
  ]);

  // Try to load feed_info.txt
  let feedInfo = null;
  const feedInfoFile = zip.file('feed_info.txt');
  if(feedInfoFile){
    const feedInfoCsv = await parseCsv(await feedInfoFile.async('text'));
    if(feedInfoCsv.length > 0){
      feedInfo = feedInfoCsv[0];
    }
  }

  // Store feed metadata globally
  window.FEED_INFO = {
    filename: file.name,
    validFrom: feedInfo?.feed_start_date || null,
    validTo: feedInfo?.feed_end_date || null,
    version: feedInfo?.feed_version || null,
    publisher: feedInfo?.feed_publisher_name || null
  };
  window.ANALYZED_AT = new Date().toISOString();

  const routeById={}; for(const r of routes){ if(r.route_id) routeById[r.route_id]=r; }
  const calByService={}; for(const c of calendar){ if(c.service_id) calByService[c.service_id]=c; }

  // origin departure per trip
  const originForTrip=new Map();
  {
    const earliest=new Map();
    for(const st of stopTimes){
      const tid=st.trip_id; if(!tid) continue;
      const seq=parseInt(st.stop_sequence||'0',10);
      const prev=earliest.get(tid);
      if(!prev || seq<prev.seq) earliest.set(tid,{seq,row:st});
    }
    for(const [tid,obj] of earliest.entries()){
      const r=obj.row;
      const dep=(r.departure_time&&r.departure_time.trim())?r.departure_time:r.arrival_time;
      const m=t2m(dep);
      if(m!=null) originForTrip.set(tid,m);
    }
  }

  function tripsForDay(day){
    // Only use calendar.txt to determine if service runs on this day type.
    // We ignore calendar_dates.txt exceptions since we're analyzing general
    // service patterns across the week, not specific dates. The previous logic
    // incorrectly excluded ALL trips for a service if ANY exception existed
    // (e.g., a Dec 25 removal would exclude all weekday trips).
    return trips.filter(tr=>{
      const serviceId=tr.service_id;
      const c=calByService[serviceId];

      if(!c) return false;

      if(day==='Weekday') return ['monday','tuesday','wednesday','thursday','friday'].some(d=>c[d]==='1');
      else if(day==='Saturday') return c['saturday']==='1';
      else if(day==='Sunday') return c['sunday']==='1';
      return false;
    });
  }

  const days=['Weekday','Saturday','Sunday'];
  const rows=[];
  const routeDayData=new Map();

  for(const day of days){
    const dayTrips=tripsForDay(day);
    const map=new Map();
    for(const tr of dayTrips){
      const dir=(tr.direction_id!==undefined && tr.direction_id!=='' && tr.direction_id!==null)? String(tr.direction_id) : '0';
      const key=`${tr.route_id}::${dir}`;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(tr.trip_id);
    }

    for(const [key,tripIds] of map.entries()){
      const [route_id,dir]=key.split('::');
      const rt=routeById[route_id]||{};
      const rname=rt.route_short_name||rt.route_long_name||route_id;

      const times=[];
      for(const tid of tripIds){
        const m=originForTrip.get(tid);
        if(m==null) continue;
        if(m<t0 || m>t1) continue; // inclusive
        times.push(m);
      }
      if(times.length<2) continue;
      times.sort((a,b)=>a-b);

      // de-duplicate identical minute marks
      const dedup=[]; for(const t of times){ if(!dedup.length || dedup[dedup.length-1]!==t) dedup.push(t); }
      if(dedup.length<2) continue;

      const gaps=[];
      for(let i=1;i<dedup.length;i++){
        const h=dedup[i]-dedup[i-1];
        if(h>=5 && h<=240) gaps.push(h);
      }
      if(gaps.length===0) continue;

      const b=bucketCounts(gaps);
      const avg=Math.round(gaps.reduce((a,b)=>a+b,0)/gaps.length);
      const best=computeMedian(gaps);
      const tier=leastWorstTier(gaps);

      rows.push({route:rname, dir, day, b, avg, best, tier, hw:gaps, times:dedup});

      // keep per-direction times and gaps for modal (by route+day)
      const routeDayKey=`${rname}::${day}`;
      if(!routeDayData.has(routeDayKey)) routeDayData.set(routeDayKey,{});
      const perDir=routeDayData.get(routeDayKey);
      // Store gaps with time info for detailed analysis
      const gapsWithTime = [];
      for(let i = 1; i < dedup.length; i++){
        const g = dedup[i] - dedup[i-1];
        if(g >= 5 && g <= 240){
          gapsWithTime.push({ gap: g, time: dedup[i-1] });
        }
      }
      perDir[dir]={times:[...dedup], tier, gaps:[...gaps], gapsWithTime};
    }
  }

  // stash per-route/day dir details
  for(const row of rows){
    const key=`${row.route}::${row.day}`;
    row.dirDetails=cloneDirDetails(routeDayData.get(key));
  }

  RAW_ROWS = rows;
  render();
  document.getElementById('tierSummary').style.display='block';
  const tableWrapEl = document.getElementById('tableWrap');
  tableWrapEl.style.display='block';
  updateResultsMaxHeight();

  // Populate and show feed metadata
  document.getElementById('feedFilename').textContent = FEED_INFO.filename;
  document.getElementById('feedValidity').textContent =
    FEED_INFO.validFrom && FEED_INFO.validTo
      ? `${FEED_INFO.validFrom} to ${FEED_INFO.validTo}`
      : 'Unknown';
  document.getElementById('analyzedTime').textContent = new Date(ANALYZED_AT).toLocaleString();
  document.getElementById('feedMetadata').style.display = 'block';

  // Detect and display historical data warning
  window.IS_HISTORICAL_DATA = detectHistoricalData();
  const historicalBanner = document.getElementById('historicalBanner');
  if(historicalBanner){
    if(window.IS_HISTORICAL_DATA){
      historicalBanner.style.display = 'block';
      const validTo = FEED_INFO.validTo || 'Unknown';
      historicalBanner.innerHTML = `<strong>Historical Data:</strong> This GTFS feed expired on ${validTo}. Results reflect past service patterns.`;
    } else {
      historicalBanner.style.display = 'none';
    }
  }

  // Show export button
  document.getElementById('exportBtn').style.display = 'inline-block';
}

function cloneDirDetails(details){
  const keys=new Set(['0','1']);
  if(details){ Object.keys(details).forEach(k=>keys.add(k)); }
  const result={};
  for(const key of keys){
    const src=details?.[key];
    result[key]={
      times: src?.times ? [...src.times] : [],
      tier: src?.tier ?? null,
      gaps: src?.gaps ? [...src.gaps] : [],
      gapsWithTime: src?.gapsWithTime ? src.gapsWithTime.map(g => ({...g})) : []
    };
  }
  return result;
}

function tierClass(t){
  if(t==='10') return 't10';
  if(t==='15') return 't15';
  if(t==='20') return 't20';
  if(t==='30') return 't30';
  if(t==='60') return 't60';
  return 'tBig';
}

function render(opts={}){
  const sortDay = currentSortDay || 'Weekday';
  const mergeCheckbox = document.getElementById('merge');
  const merge = mergeCheckbox ? mergeCheckbox.checked : true;
  const q = (document.getElementById('q').value||'').toLowerCase();

  // Build ROUTE_DATA: group by route, then by day
  ROUTE_DATA = {};
  const processedRows = merge ? mergeRows(RAW_ROWS) : RAW_ROWS.map(cloneRow);

  for(const r of processedRows){
    if(!ROUTE_DATA[r.route]) ROUTE_DATA[r.route] = {};
    ROUTE_DATA[r.route][r.day] = r;
  }

  // Get unique routes and filter by search
  let routes = Object.keys(ROUTE_DATA);
  if(q) routes = routes.filter(r => r.toLowerCase().includes(q));

  // Count tiers based on sortDay (use override tier if present)
  const tierCounts = {'10':0, '15':0, '20':0, '30':0, '60':0, '>60':0};
  for(const route of routes){
    const dayData = ROUTE_DATA[route][sortDay];
    if(dayData){
      const validation = VALIDATIONS[route]?.[sortDay];
      const hasOverride = validation?.manual_override;
      const tier = hasOverride ? tierValueToStandard(validation.manual_override.tier) : dayData.tier;
      tierCounts[tier] = (tierCounts[tier] || 0) + 1;
    }
  }

  // Update tier summary boxes
  document.querySelectorAll('.tierBox').forEach(box => {
    const tier = box.dataset.tier;
    box.querySelector('.tierCount').textContent = tierCounts[tier] || 0;
  });

  // Filter by tier if active (use override tier if present)
  if(activeTierFilter){
    routes = routes.filter(route => {
      const dayData = ROUTE_DATA[route][sortDay];
      if(!dayData) return false;
      const validation = VALIDATIONS[route]?.[sortDay];
      const hasOverride = validation?.manual_override;
      const tier = hasOverride ? tierValueToStandard(validation.manual_override.tier) : dayData.tier;
      return tier === activeTierFilter;
    });
  }

  // Sort routes by tier quality for sortDay, then alphabetically (use override tier if present)
  const tierOrder = {'10':0, '15':1, '20':2, '30':3, '60':4, '>60':5};
  routes.sort((a, b) => {
    const dayDataA = ROUTE_DATA[a][sortDay];
    const dayDataB = ROUTE_DATA[b][sortDay];
    const validationA = VALIDATIONS[a]?.[sortDay];
    const validationB = VALIDATIONS[b]?.[sortDay];
    const hasOverrideA = validationA?.manual_override;
    const hasOverrideB = validationB?.manual_override;
    const tierA = hasOverrideA ? tierValueToStandard(validationA.manual_override.tier) : (dayDataA?.tier || '>60');
    const tierB = hasOverrideB ? tierValueToStandard(validationB.manual_override.tier) : (dayDataB?.tier || '>60');
    if(tierOrder[tierA] !== tierOrder[tierB]){
      return tierOrder[tierA] - tierOrder[tierB];
    }
    return a.localeCompare(b, undefined, {numeric: true});
  });

  // Update route count
  const routeCountEl = document.querySelector('.routeCount');
  if(routeCountEl) routeCountEl.innerHTML = `Displaying <strong>${routes.length}</strong> routes`;

  // Build table with 3-day columns
  const tbody = document.querySelector('#tbl tbody');
  tbody.innerHTML = '';

  for(const route of routes){
    const tr = document.createElement('tr');
    tr.dataset.route = route;

    // Route name cell
    const routeCell = document.createElement('td');
    routeCell.className = 'route';
    routeCell.textContent = route;
    tr.appendChild(routeCell);

    // Day cells
    for(const day of ['Weekday', 'Saturday', 'Sunday']){
      const cell = document.createElement('td');
      cell.className = 'dayCell';
      const dayData = ROUTE_DATA[route][day];

      if(dayData){
        const headway = dayData.avg || 0;
        const validation = VALIDATIONS[route]?.[day];
        const hasOverride = validation?.manual_override;

        // Use override tier if present
        const displayTier = hasOverride ? validation.manual_override.tier : dayData.tier;
        const tierLabel = hasOverride ? tierToLabelFromValue(displayTier) : tierToLabel(dayData.tier);
        const tierCls = hasOverride ? tierClassFromValue(displayTier) : tierClass(dayData.tier);
        const overrideIndicator = hasOverride ? '<span class="overrideIndicator">*</span>' : '';

        cell.innerHTML = `<span class="headway">${headway}m</span><span class="tierBadge ${tierCls}">${tierLabel}</span>${overrideIndicator}`;
        cell.style.cursor = 'pointer';
        cell.addEventListener('click', (e) => {
          e.stopPropagation();
          openModal(dayData, day);
        });
      } else {
        cell.innerHTML = '<span class="noService">‚Äî</span>';
      }
      tr.appendChild(cell);
    }

    // Trips, Best, Worst columns (based on sortDay)
    const sortDayData = ROUTE_DATA[route][sortDay];

    // Trips: total departures
    const tripsCell = document.createElement('td');
    tripsCell.className = 'numCol';
    if(sortDayData){
      const dirDetails = sortDayData.dirDetails || {};
      const outboundTimes = dirDetails['0']?.times || [];
      const inboundTimes = dirDetails['1']?.times || [];
      const totalTrips = outboundTimes.length + inboundTimes.length;
      tripsCell.textContent = totalTrips || sortDayData.times?.length || '‚Äî';
    } else {
      tripsCell.textContent = '‚Äî';
    }
    tr.appendChild(tripsCell);

    // Best: median headway (representative "best" performance)
    const bestCell = document.createElement('td');
    bestCell.className = 'numCol';
    if(sortDayData && sortDayData.hw && sortDayData.hw.length){
      const best = Math.min(...sortDayData.hw);
      bestCell.textContent = best + 'm';
    } else {
      bestCell.textContent = '‚Äî';
    }
    tr.appendChild(bestCell);

    // Worst: longest gap
    const worstCell = document.createElement('td');
    worstCell.className = 'numCol';
    if(sortDayData && sortDayData.hw && sortDayData.hw.length){
      const worst = Math.max(...sortDayData.hw);
      worstCell.textContent = worst + 'm';
    } else {
      worstCell.textContent = '‚Äî';
    }
    tr.appendChild(worstCell);

    // Validation: show icon for current sortDay
    const validCell = document.createElement('td');
    validCell.className = 'validCol';
    validCell.innerHTML = getValidationIcon(route, sortDay);
    validCell.style.cursor = 'pointer';
    validCell.addEventListener('click', (e) => {
      e.stopPropagation();
      const dayData = ROUTE_DATA[route][sortDay];
      if(dayData) openModal(dayData, sortDay);
    });
    tr.appendChild(validCell);

    // Click on route name opens modal for sortDay
    routeCell.style.cursor = 'pointer';
    routeCell.addEventListener('click', () => {
      const dayData = ROUTE_DATA[route][sortDay];
      if(dayData) openModal(dayData, sortDay);
    });

    tbody.appendChild(tr);
  }

  updateResultsMaxHeight();
}

function tierToLabel(tier){
  if(tier === '10') return 'Freq+';
  if(tier === '15') return 'Freq';
  if(tier === '20') return 'Good';
  if(tier === '30') return 'Basic';
  if(tier === '60') return 'Infreq';
  return 'Sparse';
}

// Helper functions for manual override tier values
function tierToLabelFromValue(tierValue){
  // Map override dropdown values to labels
  if(tierValue === '10') return 'Freq+';
  if(tierValue === 'freq') return 'Freq';
  if(tierValue === 'good') return 'Good';
  if(tierValue === 'basic') return 'Basic';
  if(tierValue === '60') return 'Infreq';
  if(tierValue === 'infreq') return 'Sparse';
  return tierValue;
}

function tierClassFromValue(tierValue){
  // Map override dropdown values to CSS classes
  if(tierValue === '10') return 't10';
  if(tierValue === 'freq') return 't15';
  if(tierValue === 'good') return 't20';
  if(tierValue === 'basic') return 't30';
  if(tierValue === '60') return 't60';
  if(tierValue === 'infreq') return 'tBig';
  return 'tBig';
}

function tierValueToStandard(tierValue){
  // Map override dropdown values to standard tier values for export
  if(tierValue === '10') return '10';
  if(tierValue === 'freq') return '15';
  if(tierValue === 'good') return '20';
  if(tierValue === 'basic') return '30';
  if(tierValue === '60') return '60';
  if(tierValue === 'infreq') return '>60';
  return tierValue;
}

// Modal (Departures & Gaps)
function getDirDetails(route, day){
  // Build from RAW_ROWS for both directions
  const details = {'0':{times:[],tier:null}, '1':{times:[],tier:null}};
  for(const r of RAW_ROWS){
    if(r.route===route && r.day===day){
      if(String(r.dir)==='0'){ details['0'].times = details['0'].times.concat(r.times); details['0'].tier=r.tier; }
      if(String(r.dir)==='1'){ details['1'].times = details['1'].times.concat(r.times); details['1'].tier=r.tier; }
    }
  }
  for(const k of Object.keys(details)){ details[k].times.sort((a,b)=>a-b); }
  return details;
}
function buildDepartureTable(label, detail){
  const times=(detail?.times||[]).slice().sort((a,b)=>a-b);
  const uniq=[]; for(const t of times){ if(!uniq.length || uniq[uniq.length-1]!==t) uniq.push(t); }
  const tier=detail?.tier ?? null;
  let rows='';
  if(uniq.length){
    for(let i=0;i<uniq.length;i++){
      const timeStr=m2t(uniq[i]);
      if(i===0){
        rows+=`<tr><td class="numCol">${i+1}</td><td>${timeStr}</td><td>‚Äî</td></tr>`;
      }else{
        const gap=Math.round(uniq[i]-uniq[i-1]);
        rows+=`<tr><td class="numCol">${i+1}</td><td>${timeStr}</td><td>${renderGapCell(gap,tier)}</td></tr>`;
      }
    }
  }else{
    rows=`<tr><td colspan="3" class="muted">No departures in window</td></tr>`;
  }
  return `<div class="gapTableWrap"><h5>${label}</h5><div class="gapTableScroll"><table class="gapTable"><thead><tr><th>#</th><th>Time</th><th>Gap</th></tr></thead><tbody>${rows}</tbody></table></div></div>`;
}
function buildServiceWindowTable(label, windows){
  if(!windows || !windows.length){
    return `<div class="serviceWindowWrap"><h5>${label}</h5><div class="serviceWindowEmpty">Not enough departures to determine a consistent window.</div></div>`;
  }
  const rows=windows.map((win,idx)=>{
    const winLabel=win.label||'';
    const span=`${m2t(win.start)}‚Äì${m2t(win.end)}`;
    const coverage=formatDuration(win.duration);
    const best=formatHeadway(win.typical);
    const avg=formatHeadway(win.avg);
    const dep=`${win.departures}`;
    return `<tr><td>${winLabel}</td><td>${span}</td><td>${coverage}</td><td>${best} min</td><td>${avg} min</td><td>${dep}</td></tr>`;
  }).join('');
  return `<div class="serviceWindowWrap"><h5>${label}</h5><div class="serviceWindowScroll"><table class="serviceWindowTable"><thead><tr><th>Type</th><th>Window</th><th>Span</th><th>Headway</th><th>Avg</th><th>Trips</th></tr></thead><tbody>${rows}</tbody></table></div></div>`;
}

function labelServiceWindows(windows){
  if(!windows || windows.length===0) return [];
  // Label windows based on headway quality:
  // - Peak service = window(s) with shortest typical headway
  // - Base service = typical daytime headways (middle range)
  // - Off-peak service = longest headways
  const sorted=[...windows].map((w,i)=>({...w,originalIdx:i})).sort((a,b)=>a.typical-b.typical);
  const labeled=new Array(windows.length);

  if(sorted.length===1){
    labeled[sorted[0].originalIdx]={...windows[sorted[0].originalIdx], label:'Base service'};
  } else if(sorted.length===2){
    labeled[sorted[0].originalIdx]={...windows[sorted[0].originalIdx], label:'Peak service'};
    labeled[sorted[1].originalIdx]={...windows[sorted[1].originalIdx], label:'Off-peak service'};
  } else {
    // 3+ windows: best = peak, worst = off-peak, middle = base
    const bestTypical=sorted[0].typical;
    const worstTypical=sorted[sorted.length-1].typical;
    for(const w of sorted){
      let label;
      if(w.typical===bestTypical) label='Peak service';
      else if(w.typical===worstTypical) label='Off-peak service';
      else label='Base service';
      labeled[w.originalIdx]={...windows[w.originalIdx], label};
    }
  }
  return labeled;
}

function buildServiceWindowsSection(row, dirDetails, merge){
  const opts={tolerance:2,minPairs:2};
  const outboundWindows=labelServiceWindows(deriveServiceWindows(dirDetails?.['0']?.times||[], opts));
  const inboundWindows=labelServiceWindows(deriveServiceWindows(dirDetails?.['1']?.times||[], opts));

  // Only show section if at least one direction has service windows
  if(!outboundWindows.length && !inboundWindows.length) return '';

  const outboundHtml = buildServiceWindowTable('Outbound', outboundWindows);
  const inboundHtml = buildServiceWindowTable('Inbound', inboundWindows);
  return `
    <div class="serviceWindows">
      <h4>Service Periods</h4>
      <div class="sideBySide">${outboundHtml}${inboundHtml}</div>
    </div>`;
}

// Compact departure format: group by hour with HH | MM format
function buildCompactDepartures(times){
  if(!times || !times.length) return '<div class="muted">No departures</div>';
  const sorted=[...times].sort((a,b)=>a-b);
  const byHour=new Map();
  for(const t of sorted){
    const h=Math.floor(t/60);
    if(!byHour.has(h)) byHour.set(h,[]);
    byHour.get(h).push(String(t%60).padStart(2,'0'));
  }
  let html='';
  for(const [hour,mins] of [...byHour.entries()].sort((a,b)=>a[0]-b[0])){
    const hourDisplay=String(hour).padStart(2,'0');
    html+=`<div class="hourRow"><span class="hourLabel">${hourDisplay}</span><span class="hourPipe">|</span><div class="hourMins">${mins.join('  ')}</div></div>`;
  }
  return html;
}

function buildCompactDeparturesSection(dirDetails, collapsed=true){
  const outboundTimes=dirDetails?.['0']?.times||[];
  const inboundTimes=dirDetails?.['1']?.times||[];
  return `
    <div class="sideBySide">
      <div class="directionBlock"><h5>Outbound</h5>${buildCompactDepartures(outboundTimes)}</div>
      <div class="directionBlock"><h5>Inbound</h5>${buildCompactDepartures(inboundTimes)}</div>
    </div>`;
}



function buildGapDistributionBars(headways){
  if(!headways || !headways.length) return '<div class="muted">No gap data available</div>';

  // Bucket gaps into categories
  const buckets = [
    {label: '‚â§10 min', min: 0, max: 10, count: 0, tierClass: 'tier10'},
    {label: '11-15 min', min: 11, max: 15, count: 0, tierClass: 'tier15'},
    {label: '16-20 min', min: 16, max: 20, count: 0, tierClass: 'tier20'},
    {label: '21-30 min', min: 21, max: 30, count: 0, tierClass: 'tier30'},
    {label: '>30 min', min: 31, max: Infinity, count: 0, tierClass: 'tier60'}
  ];

  for(const h of headways){
    for(const b of buckets){
      if(h >= b.min && h <= b.max){
        b.count++;
        break;
      }
    }
  }

  const maxCount = Math.max(...buckets.map(b => b.count), 1);

  const rows = buckets.map(b => {
    const pct = (b.count / maxCount) * 100;
    const tripLabel = b.count === 1 ? 'trip' : 'trips';
    return `
      <div class="gapDistRow">
        <span class="gapDistLabel">${b.label}</span>
        <div class="gapDistBarWrap">
          <div class="gapDistBar ${b.tierClass}" style="width:${pct}%"></div>
        </div>
        <span class="gapDistCount">${b.count} ${tripLabel}</span>
      </div>`;
  }).join('');

  return `
    <div class="gapDistribution">
      <h4>Gap Distribution</h4>
      <div class="gapDistContainer">
        <div class="gapDistBars">
          ${rows}
        </div>
      </div>
    </div>`;
}
let currentModalRoute = null;
let currentModalDay = 'Weekday';

function openModal(r, day){
  currentModalRoute = r.route;
  currentModalDay = day || r.day;

  const modal = document.getElementById('modal');
  modal.style.display='flex';

  renderModalContent();
}

function renderModalContent(){
  const route = currentModalRoute;
  const day = currentModalDay;

  // Get data for this route and day
  const r = ROUTE_DATA[route]?.[day];
  if(!r){
    document.getElementById('modalBody').innerHTML = '<p class="muted">No data available for this day.</p>';
    return;
  }

  const t0 = document.getElementById('t0').value || '07:00';
  const t1 = document.getElementById('t1').value || '22:00';

  // Build modal header with day tabs in top bar
  const headerHtml = `
    <div class="modalRouteHeader">
      <span class="modalRouteBadge">${route}</span>
      <div class="modalDayTabs">
        <button class="modalDayTab ${day==='Weekday'?'active':''}" onclick="switchModalDay('Weekday')">WEEKDAY</button>
        <button class="modalDayTab ${day==='Saturday'?'active':''}" onclick="switchModalDay('Saturday')">SATURDAY</button>
        <button class="modalDayTab ${day==='Sunday'?'active':''}" onclick="switchModalDay('Sunday')">SUNDAY</button>
      </div>
    </div>
  `;

  document.getElementById('modalTitle').innerHTML = headerHtml;

  const dirDetails = r.dirDetails || getDirDetails(route, day);
  const validation = VALIDATIONS[route]?.[day];

  // Calculate separate direction stats
  const outboundTimes = dirDetails?.['0']?.times || [];
  const inboundTimes = dirDetails?.['1']?.times || [];

  const outboundGaps = dirDetails?.['0']?.gaps?.length ? dirDetails['0'].gaps : calculateGaps(outboundTimes);
  const inboundGaps = dirDetails?.['1']?.gaps?.length ? dirDetails['1'].gaps : calculateGaps(inboundTimes);

  const outboundAvg = outboundGaps.length ? Math.round(outboundGaps.reduce((a,b)=>a+b,0)/outboundGaps.length) : null;
  const inboundAvg = inboundGaps.length ? Math.round(inboundGaps.reduce((a,b)=>a+b,0)/inboundGaps.length) : null;

  const outboundMaxGap = outboundGaps.length ? Math.max(...outboundGaps) : null;
  const inboundMaxGap = inboundGaps.length ? Math.max(...inboundGaps) : null;

  const totalTrips = outboundTimes.length + inboundTimes.length;

  // Calculate worst gap from pooled gaps (both directions)
  const worstGap = r.hw && r.hw.length ? Math.max(...r.hw) : null;

  // Get max gap info with direction/time (from mergeRows data or calculate)
  let maxGapInfo = r.maxGapInfo;
  if(!maxGapInfo && worstGap !== null){
    // Fallback: find it in dirDetails
    for(const dirKey of ['0', '1']){
      const gapsWithTime = dirDetails?.[dirKey]?.gapsWithTime || [];
      for(const g of gapsWithTime){
        if(!maxGapInfo || g.gap > maxGapInfo.gap){
          maxGapInfo = { gap: g.gap, direction: dirKey, time: g.time };
        }
      }
    }
  }

  // Count violations across ALL pooled gaps
  const allGaps = [...outboundGaps, ...inboundGaps];
  const violations = countViolations(allGaps, r.tier);

  // Check for manual override
  const hasOverride = validation?.manual_override;
  const displayTier = hasOverride ? validation.manual_override.tier : r.tier;
  const displayTierLabel = hasOverride ? tierToLabelFromValue(validation.manual_override.tier) : tierToLabel(r.tier);
  const displayTierClass = hasOverride ? tierClassFromValue(validation.manual_override.tier) : tierClass(r.tier);

  // Format max gap location info
  const maxGapDirLabel = maxGapInfo?.direction === '0' ? 'Outbound' : maxGapInfo?.direction === '1' ? 'Inbound' : 'Unknown';
  const maxGapTimeStr = maxGapInfo?.time != null ? m2t(maxGapInfo.time) : '';

  // Get threshold for current tier
  const tierThresholds = {
    't10': '‚â§10 min', 'tier10': '‚â§10 min',
    't15': '‚â§15 min', 'tier15': '‚â§15 min',
    't20': '‚â§20 min', 'tier20': '‚â§20 min',
    't30': '‚â§30 min', 'tier30': '‚â§30 min',
    't60': '‚â§60 min', 'tier60': '‚â§60 min',
    'tBig': '>60 min', 'tierBig': '>60 min'
  };
  const currentTierThreshold = tierThresholds[displayTierClass] || '';

  // Build 4-column stats row: Frequency | Analysis | Outbound | Inbound
  const statsCardsHtml = `
    <div class="statsRow">
      <div class="statCard frequencyCard">
        <div class="freqHeader">
          <span class="freqBadge ${displayTierClass}">${displayTierLabel}</span>
          <span class="freqThreshold">${currentTierThreshold}</span>
        </div>
        <div class="freqStatRow"><span>Exceptions:</span> <strong>${violations.grace}</strong> <span class="muted">(out of 2)</span></div>
      </div>
      <div class="statCard analysisCard">
        <div class="label" style="margin-bottom:8px">COMBINED ANALYSIS</div>
        <div class="combinedStats">
          <div class="combinedRow">
            <span class="statLabel">Max gap:</span>
            <span class="statValue">${worstGap !== null ? `<strong>${worstGap}m</strong>` : '‚Äî'}${maxGapInfo ? ` <span class="muted">(${maxGapDirLabel} at ${maxGapTimeStr})</span>` : ''}</span>
          </div>
          <div class="combinedRow">
            <span class="statLabel">Total trips:</span>
            <span class="statValue"><strong>${totalTrips}</strong> <span class="muted">(${outboundTimes.length} out, ${inboundTimes.length} in)</span></span>
          </div>
          <div class="combinedRow">
            <span class="statLabel">Violations:</span>
            <span class="statValue">${violations.hard > 0 ? `<span class="violationBadge hard">${violations.hard} hard</span>` : ''}${violations.grace > 0 ? `<span class="violationBadge grace">${violations.grace} grace</span>` : ''}${violations.hard === 0 && violations.grace === 0 ? '<span class="muted">None</span>' : ''}</span>
          </div>
        </div>
      </div>
      <div class="statCard dirCard">
        <div class="dirHeader">
          <span class="dirBadgeSmall outbound">Outbound</span>
          <span class="tripCountSmall">${outboundTimes.length} trips</span>
        </div>
        <div class="dirStatRow"><span>Avg headway:</span> <strong>${outboundAvg !== null ? outboundAvg + 'm' : '‚Äî'}</strong></div>
        <div class="dirStatRow"><span>Max gap:</span> <strong>${outboundMaxGap !== null ? outboundMaxGap + 'm' : '‚Äî'}</strong></div>
      </div>
      <div class="statCard dirCard">
        <div class="dirHeader">
          <span class="dirBadgeSmall inbound">Inbound</span>
          <span class="tripCountSmall">${inboundTimes.length} trips</span>
        </div>
        <div class="dirStatRow"><span>Avg headway:</span> <strong>${inboundAvg !== null ? inboundAvg + 'm' : '‚Äî'}</strong></div>
        <div class="dirStatRow"><span>Max gap:</span> <strong>${inboundMaxGap !== null ? inboundMaxGap + 'm' : '‚Äî'}</strong></div>
      </div>
    </div>
  `;

  // Build chart with separate direction lines
  const chartSection = buildDirectionalChart(dirDetails, r.tier);

  // Build gap distribution section (horizontal bar chart)
  const gapDistSection = buildGapDistributionBars(r.hw);

  // Build departure times section
  const departuresSection = buildCompactDeparturesSection(dirDetails, false);

  // Build service windows section
  const serviceWindowsSection = buildServiceWindowsSection(r, dirDetails, true);

  // Build validation panel
  const feedValidity = FEED_INFO?.validFrom && FEED_INFO?.validTo
    ? `${FEED_INFO.validFrom} to ${FEED_INFO.validTo}`
    : 'Unknown';
  const analyzedAt = ANALYZED_AT ? new Date(ANALYZED_AT).toLocaleString() : 'Unknown';
  const verifiedAt = validation?.verifiedAt ? new Date(validation.verifiedAt).toLocaleString() : 'Not verified';

  // Get lineage data for this route
  const lineage = getRouteLineage(route);

  const validationPanelHtml = `
    <div class="validationPanel panel">
      <h4>Validation Status</h4>

      <div class="overrideSection">
        <label class="overrideLabel">
          <input type="checkbox" id="manualOverride" ${validation?.manual_override ? 'checked' : ''} onchange="toggleManualOverride()">
          <span>Manual Override</span>
        </label>

        <div id="manualTierSelect" style="display:${validation?.manual_override ? 'block' : 'none'};margin-top:8px">
          <label>Correct tier (overrides calculation):</label>
          <select id="manualTier" class="tierSelect">
            <option value="">-- Select tier --</option>
            <option value="10" ${validation?.manual_override?.tier === '10' ? 'selected' : ''}>10 (‚â§10 min)</option>
            <option value="freq" ${validation?.manual_override?.tier === 'freq' ? 'selected' : ''}>Freq (‚â§15 min)</option>
            <option value="good" ${validation?.manual_override?.tier === 'good' ? 'selected' : ''}>Good (‚â§20 min)</option>
            <option value="basic" ${validation?.manual_override?.tier === 'basic' ? 'selected' : ''}>Basic (‚â§30 min)</option>
            <option value="60" ${validation?.manual_override?.tier === '60' ? 'selected' : ''}>60 (‚â§60 min)</option>
            <option value="infreq" ${validation?.manual_override?.tier === 'infreq' ? 'selected' : ''}>Infreq (>60 min)</option>
          </select>

          <label style="margin-top:8px">Why override?</label>
          <textarea id="overrideReason" placeholder="e.g., GTFS data doesn't match PDF schedule - actual service is every 15 min" rows="2">${validation?.manual_override?.reason || ''}</textarea>
        </div>
      </div>

      <div class="divider" style="margin: 12px 0; border-top: 1px solid var(--line);"></div>

      <div class="validationControls">
        <label>Status</label>
        <select id="validationStatus" onchange="toggleExpectedTierDiv()">
          <option value="unverified" ${!validation || validation.status === 'unverified' ? 'selected' : ''}>? Unverified</option>
          <option value="correct" ${validation?.status === 'correct' ? 'selected' : ''}>‚úì Correct</option>
          <option value="incorrect" ${validation?.status === 'incorrect' ? 'selected' : ''}>‚úó Incorrect</option>
        </select>

        <label>Notes</label>
        <textarea id="validationNotes" placeholder="e.g., Checked against Jan 2025 PDF schedule" rows="3">${validation?.notes || ''}</textarea>

        <div id="incorrectTierDiv" style="display:${validation?.status === 'incorrect' ? 'block' : 'none'}">
          <label>Expected Tier (if incorrect)</label>
          <select id="expectedTier">
            <option value="10" ${validation?.expectedTier === '10' ? 'selected' : ''}>Freq+ (‚â§10 min)</option>
            <option value="15" ${validation?.expectedTier === '15' ? 'selected' : ''}>Freq (‚â§15 min)</option>
            <option value="20" ${validation?.expectedTier === '20' ? 'selected' : ''}>Good (‚â§20 min)</option>
            <option value="30" ${validation?.expectedTier === '30' ? 'selected' : ''}>Basic (‚â§30 min)</option>
            <option value="60" ${validation?.expectedTier === '60' ? 'selected' : ''}>Infreq (‚â§60 min)</option>
            <option value=">60" ${validation?.expectedTier === '>60' ? 'selected' : ''}>Sparse (>60 min)</option>
          </select>
        </div>

        <div class="dataSourceGroup">
          <label>Data Source</label>
          <div class="dataSourceRadios">
            <label><input type="radio" name="dataSource" id="dataSourceGtfs" value="gtfs" ${!validation?.data_source || validation?.data_source === 'gtfs' ? 'checked' : ''} onchange="toggleSourceNotes()"> GTFS Feed</label>
            <label><input type="radio" name="dataSource" id="dataSourceManual" value="manual" ${validation?.data_source === 'manual' ? 'checked' : ''} onchange="toggleSourceNotes()"> Manual Entry</label>
          </div>
          <div id="sourceNotesDiv" style="display:${validation?.data_source === 'manual' ? 'block' : 'none'}">
            <label>Source Notes</label>
            <textarea id="sourceNotes" placeholder="e.g., Data entered from PDF timetable, agency website, etc." rows="2">${validation?.source_notes || ''}</textarea>
          </div>
        </div>

        <button onclick="saveValidation()" class="btn">Save Validation</button>
      </div>

      <div class="validationMeta">
        <div><strong>Feed validity:</strong> <span id="modalFeedValidity">${feedValidity}</span></div>
        <div><strong>Analyzed:</strong> <span id="modalAnalyzedAt">${analyzedAt}</span></div>
        <div><strong>Last verified:</strong> <span id="verifiedAt">${verifiedAt}</span></div>
        ${window.IS_HISTORICAL_DATA ? '<div style="color:#f59e0b;font-weight:700">This is historical data (feed has expired)</div>' : ''}
      </div>
    </div>

    <div class="lineagePanel">
      <h4>Route Lineage Metadata</h4>
      <div class="lineageControls">
        <label>Stable ID (optional)</label>
        <input type="text" id="lineageStableId" placeholder="e.g., route-101-main-corridor" value="${lineage.stable_id || ''}">

        <label>Route Changes</label>
        <p class="helpText">Has this route changed since your last analysis? (Select all that apply)</p>
        ${buildChangeTypeCheckboxes(lineage.route_changes?.changes || [])}

        <label style="margin-top:12px">Additional details:</label>
        <textarea id="routeChangeNotes" placeholder="e.g., Extended 2 miles north, merged with Route 5 south of downtown" rows="3">${lineage.route_changes?.notes || ''}</textarea>

        <button onclick="saveLineage()" class="btn">Save Lineage</button>
      </div>
    </div>
  `;

  const body = document.getElementById('modalBody');
  body.innerHTML = `
    <div class="modalGrid">
      <div class="modalMain">
        ${statsCardsHtml}
        <div class="chartsRow">
          ${chartSection}
          ${gapDistSection}
        </div>
        <div class="compactDepartures">
          <h4>Departure Times</h4>
          ${departuresSection}
        </div>
        ${serviceWindowsSection}
      </div>
      <div class="modalSidebar">
        ${validationPanelHtml}
      </div>
    </div>
  `;
}

function switchModalDay(day){
  currentModalDay = day;
  renderModalContent();
}

function calculateGaps(times){
  if(!times || times.length < 2) return [];
  const sorted = [...times].sort((a,b) => a-b);
  const gaps = [];
  for(let i = 1; i < sorted.length; i++){
    const gap = sorted[i] - sorted[i-1];
    if(gap >= 5 && gap <= 240) gaps.push(gap);
  }
  return gaps;
}

function buildDirectionalChart(dirDetails, tier){
  const outboundTimes = (dirDetails?.['0']?.times || []).sort((a,b)=>a-b);
  const inboundTimes = (dirDetails?.['1']?.times || []).sort((a,b)=>a-b);

  if(outboundTimes.length < 2 && inboundTimes.length < 2) return '<p class="muted">Not enough data for chart</p>';

  // Chart dimensions
  const width = 850, height = 200, padL = 50, padR = 20, padT = 25, padB = 40;
  const chartW = width - padL - padR;
  const chartH = height - padT - padB;

  // Time scale
  const t0 = document.getElementById('t0')?.value || '07:00';
  const t1 = document.getElementById('t1')?.value || '22:00';
  const minTime = t2m(t0);
  const maxTime = t2m(t1);

  // Calculate gaps for each direction
  const outboundData = [];
  for(let i = 1; i < outboundTimes.length; i++){
    const gap = outboundTimes[i] - outboundTimes[i-1];
    if(gap >= 5 && gap <= 120){
      outboundData.push({time: outboundTimes[i-1], gap});
    }
  }

  const inboundData = [];
  for(let i = 1; i < inboundTimes.length; i++){
    const gap = inboundTimes[i] - inboundTimes[i-1];
    if(gap >= 5 && gap <= 120){
      inboundData.push({time: inboundTimes[i-1], gap});
    }
  }

  // Find max gap for Y scale
  const allGaps = [...outboundData.map(d=>d.gap), ...inboundData.map(d=>d.gap)];
  const maxGap = Math.min(60, Math.max(12, ...allGaps) + 5);

  const scaleX = t => (t - minTime) / (maxTime - minTime) * chartW;
  const scaleY = g => chartH - (g / maxGap) * chartH;

  // Build outbound path (cyan)
  let outPath = '';
  let outDots = '';
  if(outboundData.length >= 1){
    outPath = `M ${padL + scaleX(outboundData[0].time)} ${padT + scaleY(outboundData[0].gap)}`;
    for(let i = 1; i < outboundData.length; i++){
      outPath += ` L ${padL + scaleX(outboundData[i].time)} ${padT + scaleY(outboundData[i].gap)}`;
    }
    outDots = outboundData.map(d =>
      `<circle cx="${padL + scaleX(d.time)}" cy="${padT + scaleY(d.gap)}" r="4" fill="#06b6d4"/>`
    ).join('');
  }

  // Build inbound path (green)
  let inPath = '';
  let inDots = '';
  if(inboundData.length >= 1){
    inPath = `M ${padL + scaleX(inboundData[0].time)} ${padT + scaleY(inboundData[0].gap)}`;
    for(let i = 1; i < inboundData.length; i++){
      inPath += ` L ${padL + scaleX(inboundData[i].time)} ${padT + scaleY(inboundData[i].gap)}`;
    }
    inDots = inboundData.map(d =>
      `<circle cx="${padL + scaleX(d.time)}" cy="${padT + scaleY(d.gap)}" r="4" fill="#10b981"/>`
    ).join('');
  }

  // X-axis labels
  const xLabels = [];
  for(let h = Math.ceil(minTime/60); h <= Math.floor(maxTime/60); h++){
    const x = padL + scaleX(h * 60);
    const label = h > 12 ? `${h-12}p` : h === 12 ? '12p' : h === 0 ? '12a' : `${h}a`;
    xLabels.push(`<text x="${x}" y="${height - 8}" class="chartAxisLabel" text-anchor="middle">${label}</text>`);
  }

  // Y-axis labels
  const yLabels = [];
  const yTicks = [0, 10, 20, 30, maxGap > 40 ? 40 : null, maxGap > 50 ? 60 : null].filter(v => v !== null && v <= maxGap);
  for(const g of yTicks){
    const y = padT + scaleY(g);
    yLabels.push(`<text x="${padL - 8}" y="${y + 4}" class="chartAxisLabel" text-anchor="end">${g}</text>`);
    yLabels.push(`<line x1="${padL}" y1="${y}" x2="${padL + chartW}" y2="${y}" stroke="var(--line)" stroke-dasharray="2,2"/>`);
  }

  return `
    <div class="chartSection">
      <h4>Frequency Throughout Day</h4>
      <div class="chartContainer">
        <svg class="chartSvg" viewBox="0 0 ${width} ${height}" style="height:200px">
          <!-- Axes -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${padT + chartH}" class="chartAxis"/>
          <line x1="${padL}" y1="${padT + chartH}" x2="${padL + chartW}" y2="${padT + chartH}" class="chartAxis"/>
          ${yLabels.join('')}
          ${xLabels.join('')}

          <!-- Outbound line (cyan) -->
          ${outPath ? `<path d="${outPath}" fill="none" stroke="#06b6d4" stroke-width="2"/>` : ''}
          ${outDots}

          <!-- Inbound line (green) -->
          ${inPath ? `<path d="${inPath}" fill="none" stroke="#10b981" stroke-width="2"/>` : ''}
          ${inDots}

          <text x="8" y="${padT + chartH/2}" class="chartAxisLabel" transform="rotate(-90,8,${padT + chartH/2})">Headway (min)</text>
        </svg>
        <div class="chartLegendDir">
          <span><span class="dot" style="background:#06b6d4"></span>Outbound</span>
          <span><span class="dot" style="background:#10b981"></span>Inbound</span>
        </div>
      </div>
    </div>
  `;
}
function closeModal(){ document.getElementById('modal').style.display='none'; }

function updateResultsMaxHeight(){
  const results=document.getElementById('resultsScroll');
  if(!results) return;
  results.style.removeProperty('max-height');
  results.style.overflow='visible';
}

// Export functions
function exportResults(){
  const agency = prompt('Enter agency slug (e.g., spokane-transit):');
  if(!agency) return;

  const agencyName = prompt('Enter agency full name (e.g., Spokane Transit Authority):');
  if(!agencyName) return;

  const data = {
    schema_version: '1.1',

    check: {
      id: `${agency}_${new Date().toISOString().split('T')[0]}`,
      created_at: ANALYZED_AT,
      is_historical: window.IS_HISTORICAL_DATA || false
    },

    agency: {
      id: agency,
      name: agencyName
    },

    gtfs_feed: {
      filename: FEED_INFO?.filename || 'unknown.zip',
      valid_from: FEED_INFO?.validFrom || null,
      valid_to: FEED_INFO?.validTo || null,
      version: FEED_INFO?.version || null,
      publisher: FEED_INFO?.publisher || null
    },

    methodology: {
      version: '1.0',
      window_start: document.getElementById('t0').value,
      window_end: document.getElementById('t1').value,
      grace_minutes: 5,
      max_violations: 2,
      merge_directions: document.getElementById('merge').checked
    },

    routes: buildRouteExports()
  };

  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${agency}_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function buildRouteExports(){
  const routes = [];

  for(const routeName of Object.keys(ROUTE_DATA)){
    const route = {
      route_id: routeName,
      route_name: routeName
    };

    // Add lineage metadata if exists
    const lineage = ROUTE_LINEAGE[routeName];
    if(lineage){
      // Include stable_id if set
      if(lineage.stable_id){
        route.stable_id = lineage.stable_id;
      }

      // Include route_changes if any changes selected or notes provided
      const rc = lineage.route_changes;
      if(rc && (rc.changes?.length > 0 || rc.notes || rc.comparable_to_previous === false)){
        route.route_changes = {
          changes: rc.changes || [],
          comparable_to_previous: rc.comparable_to_previous !== false,
          notes: rc.notes || ''
        };
      }
    }

    for(const day of ['Weekday', 'Saturday', 'Sunday']){
      const dayData = ROUTE_DATA[routeName][day];
      if(!dayData) continue;

      const dayKey = day.toLowerCase();
      const validation = VALIDATIONS[routeName]?.[day];
      const override = validation?.manual_override;

      // Calculate calculated tier and determine final tier
      const calculatedTier = dayData.tier;
      const finalTier = override?.tier ? tierValueToStandard(override.tier) : calculatedTier;

      route[dayKey] = {
        tier: finalTier,
        calculated_tier: calculatedTier,
        is_override: !!override,
        override_reason: override?.reason || '',
        avg_headway: dayData.avg,
        best_headway: dayData.best,
        max_gap: Math.max(...dayData.hw),
        total_trips: dayData.times.length,
        violations: dayData.hw.filter(h => h > tierThreshold(dayData.tier) && h <= tierThreshold(dayData.tier) + 5).length
      };

      // Include validation if exists
      if(validation){
        route[dayKey].validation = {
          status: validation.status,
          verified_at: validation.verifiedAt,
          notes: validation.notes,
          expected_tier: validation.expectedTier,
          data_source: validation.data_source || 'gtfs',
          source_notes: validation.source_notes || ''
        };
      }
    }

    routes.push(route);
  }

  return routes;
}
</script>
</body>
</html>